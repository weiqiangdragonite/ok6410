<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：3/8页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">79</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>引导启动模块。</span><span class='green'>这个模块的主要功能是引导开发板的启动，主要是以ARM汇编为主。</span><span class='green'>主要包括设置ARM异常向量的地址、设置外设接口的地址、关闭看门狗、设置CPU的主频、初始化SDRAM和NAND Flash、把代码复制到SDRAM中等。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">80</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统更新模块。</span><span class='green'>由于操作系统不可能一次编写，就能成功运行所有功能，因此需要不停的往开发板重复烧写新的操作系统程序。</span><a href='../sentence_detail/197.htm' target='right' class='orange' >由于每次烧写目标程序时都需要使用 u- boot在 Windows下才能把程序写进 NAND Flash上，</a><span class='green'>比较麻烦，而且在 Linux下没有相关的 Linux驱动，因此，本课题里设计了一段能自行更新 NAND Flash上目标程序的代码，</span><span class='green'>并集合到系统上。</span><span class='green'>这个系统更新模块主要采用串口通信来获取新的目标程序，系统引导启动后就能直接选择更新系统或者运行系统，即方便又简单。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">81</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>串口通信模块。</span><span class='green'>这里的串口通信模块主要方便调试，开发板通过串口与主机进行通信，可以让开发板输出相关的信息，然后在主机上显示，而且这个串口通信模块还包括主机上的串口通信软件。</span><span class='green'>这个通信软件是本课题里自行编写的软件，其中串口通信方面采用了第三方写的插件，而且这个软件结合系统更新模块，</span><span class='green'>主要是通过串口来传输二进制文件来更新开发板上的系统程序代码。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">82</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>操作系统模块。</span><a href='../sentence_detail/206.htm' target='right' class='orange' >本模块可以分为任务 管理 模块、中断 服务 模块、时间 管理 模块和内存 管理 模块。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">83</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/207.htm' target='right' class='red' >图3-1 嵌入式操作系统的总体模块图</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">84</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.3 引导启动模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">85</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>引导启动模块是整个嵌入式系统的首要模块，主要功能就是引导并启动操作系统，跟bootloader类似。</span><span class='green'>整个引导启动模块所做的工作首先就是初始化相关的硬件，然后跳到系统的启动界面。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">86</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>引导启动模块往往与芯片和开发板紧密结合，因此不同的开发板其实现过程往往不同，但其思路基本是一样的，下面基于OK6410开发板，介绍其引导模块的设计过程。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">87</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/212.htm' target='right' class='red' >设置 异常 处理 函数 的入口地址。</a><a href='../sentence_detail/213.htm' target='right' class='orange' >根据 ARM的体系结构可知，地址0 x0000000到0 x0000001 F是 ARM异常向量的入口地址，</a><a href='../sentence_detail/214.htm' target='right' class='orange' >当 ARM芯片启动或复位后，系统会自动从0 x00000000的地址处开始执行程序，因此我们需要在0 x00000000处设置一条跳转指令，</a><a href='../sentence_detail/215.htm' target='right' class='orange' >跳转到程序的初始化处，其余的异常向量入口地址需要填写相应的异常处理函数的入口地址，</a><a href='../sentence_detail/216.htm' target='right' class='orange' >以便异常发生时，系统跳转到相应的处理函数处。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">88</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>初始化相关的硬件。</span><a href='../sentence_detail/218.htm' target='right' class='orange' >当系统进入初始化处程序后，就进行相关的硬件的初始化了。</a><span class='green'>这里首先要禁止所有的IRQ和FIQ中断，然后根据S3C6410的芯片手册[4]，还需设置外设寄存器的地址后才能设置相关寄存器的值。</span><span class='green'>接着是关闭看门狗，大多数嵌入式芯片都有看门狗的功能，因此需要关闭看门狗，不然系统会每隔一段时间就会自动重启。</span><span class='green'>然后初始化其它的硬件，比如CPU的频率，SDRAM和NAND Flash，这些寄存器的设置只需根据相关的芯片手册来进行初始化即可。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">89</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（3）系统硬件初始化完后，还需要进行重定位代码。</span><span class='green'>由于 S3 C6410芯片启动后会自动从 NAND Flash中复制8 KB的数据到芯片的 SRAM中运行，</span><span class='green'>但往往一个操作系统的大小会超过8 KB，因此，我们需要把程序复制到内存 SDRAM上，</span><span class='green'>然后从 SRAM跳到 SDRAM中继续运行，这一步骤就是重定位。</span><a href='../sentence_detail/226.htm' target='right' class='orange' >重定位只需将NAND Flash中的代码段TEXT和数据段DATA复制到SDRAM中，最后清零BSS段即可。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">90</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/227.htm' target='right' class='orange' >重定位后，就准备跳到SDRAM中继续执行代码了。</a><span class='green'>这里一般是跳到main函数开始执行主程序，但在本系统中，由于存在系统更新模块，因此是首先跳入到更新函数，然后再执行main函数。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">91</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后是异常处理程序的编写。</span><a href='../sentence_detail/230.htm' target='right' class='orange' >由于发生异常后，系统会跳到异常向量地址处，执行异常向量地址处的函数。</a><a href='../sentence_detail/231.htm' target='right' class='orange' >在进入异常处理程序前，首先需要保存当前任务数据，即将CPU相应的寄存器数据入栈。</a><span class='green'>由于ARM存在流水线的问题，因此寄存器LR的返回地址不一定是正确的返回地址，需要根据哪种异常来进行修改。</span><a href='../sentence_detail/233.htm' target='right' class='orange' >然后进入异常处理程序，当异常处理完毕后，还原被中断任务数据。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">92</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>ARM有7种异常，由于复位异常不需编写异常处理程序，所以实际只需编写6个异常处理的函数。</span><span class='green'>但因为本系统中只用到外部中断IRQ，所以只编写了IRQ的处理函数，其余5个异常处理程序，开发者可根据实际需要进行编写。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">93</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.4 串口通信模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">94</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>串口通信模块对于嵌入式系统的调试是非常重要的，本模块可分为主机和开发板两部分，开发板和主机通过串口可以互相发送和接收数据。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">95</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>绝大多数的开发板都有一个串口插座，OK6410开发板有一个DB9的串口母座，可直接与计算机的串口进行连接通信。</span><span class='green'>要进行串口的通信，首先需要设置开发板的串口，比如串口波特率，数据位，停止位，校验位等，可根据芯片手册来设置相应的寄存器。</span><span class='green'>要通过开发板的串口发送数据，只需将该数据逐位写到相应的寄存器便可发送到PC的串口上，接收数据也是类似，从相应的寄存器去读取数据。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">96</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>开发板上实现基本的串口通信比较简单，而在主机上，比如 Windows系统，往往有较多的串口通信软件，</span><span class='green'>但由于本系统存在系统更新模块，而系统的更新，是通过串口来获取新的程序代码来实现的，</span><span class='green'>因此，本系统还实现了一个能够发送二进制文件的串口通信软件。</span><span class='green'>该软件基于Qt来开发，串口通信的实现主要通过第三方的插件来实现，除了基本的串口通信外，还能配合系统的更新模块来发送更新系统的程序，简单方便。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">97</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.5 系统更新模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">98</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/246.htm' target='right' class='orange' >当程序进入系统更新模块后，就可以选择更新系统程序或者运行系统。</a><span class='green'>系统更新模块主要用到串口通信，利用串口通信来接收主机的系统更新代码，把代码复制到NAND Flash上，然后重启系统，就能运行新的系统程序了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">99</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统更新模块的难点主要在于接收新的代码和把代码写入到NAND Flash上。</span><span class='green'>本系统从内存地址0x5FC00000（离内存尾端4MB）处开始存放系统的更新代码，当接收完代码数据后，然后在将数据写入到NAND Flash上。</span><span class='green'>不同的NAND Flash其读写的数据方式也不同，因此需要根据NAND Flash的芯片手册来进行编写。</span><span class='green'>这里还要注意S3C6410上的NAND Flash陷阱，OK6410开发板的NAND FLash是以页来读取数据的，每页有4KB是用来存储数据，218个字节来存放校验和等信息。</span><span class='green'>按照原理，S3C6410处理器是从前两页读取8KB的数据到SRAM中，但其实并不是这样的。</span><span class='green'>S3 C6410会从前4页，每页读取2 KB，总共8 KB的数据到 SRAM中，所以，当把系统代码更新时，</span><a href='../sentence_detail/254.htm' target='right' class='orange' >并不能直接把数据从 NAND Flash的第一页开始写下去，</a><span class='green'>而是需要把8 KB数据写到4页里，</span><a href='../sentence_detail/256.htm' target='right' class='orange' >第2到第5页的前2 KB数据与前一页的后2 KB数据相同，</a><span class='green'>如下图所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">100</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-2 NAND Flash前4页的数据写法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">101</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>至此，关于开发板从启动到准备运行操作系统，本设计把这一阶段分为了三个模块来讲解，</span><span class='green'>其中串口通信模块和系统更新模块并不是必须的，但对于系统的调试和更新是非常方便的，</span><span class='green'>如果到了应用正式部署的时候，可以选择性的删除。</span><span class='green'>这三个模块与开发板的硬件紧密结合，不同的开发板其实现过程也是不同的，因此这里只是简单的介绍了在OK6410下的设计过程，其它的需要根据实际的开发板进行相应的移植和修改。</span><span class='green'>当系统的环境准备好后，就可以开始载入操作系统并开始运行了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">102</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6 任务管理模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">103</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.1 任务的定义及其结构</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">104</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/266.htm' target='right' class='orange' >当人们在生活中遇到一个大而困难的问题时，往往会把这个大问题分解成多个简单和容易解决的小问题。</a><span class='green'>在实际编程中，当面对大的应用程序时，我们也会把它编写成一个个小程序来完成目的，这种方法即能提高CPU的利用率，同时又缩短程序的执行时间。</span><span class='green'>由于嵌入式系统都是与具体的应用紧密结合的，都是针对解决某一类问题，因此可以把这一类问题分解成许多小问题，再交给操作系统来进行处理。</span><span class='green'>利用这种思路，在嵌入式操作系统里，就可以把每个大问题转化为多个任务，每个任务都有自己相应的工作函数，</span><span class='green'>由操作系统来进行任务的调度和管理，这样就能实现一个多任务的操作系统了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">105</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>每个任务可以看做是一个线程，都是一段简单的程序，典型的任务都是一个无限循环的函数，由任务控制块来进行管理，</span><a href='../sentence_detail/272.htm' target='right' class='orange' >一般都包括任务的栈地址，任务的优先级，任务的函数地址等信息[7]。</a><a href='../sentence_detail/273.htm' target='right' class='red' >每个任务都属于整个应用的某一部分，都被赋予一定的优先级，有自己独立的栈空间，彼此独立运行[6]。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">106</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本论文设计的嵌入式操作系统由任务控制块链表来管理各个任务，任务的基本模型如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">107</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-3 任务链表</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">108</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/276.htm' target='right' class='orange' >任务可以分为普通任务和系统任务，系统任务为空闲任务和统计任务，空闲任务是必须存在的，当系统没有其它任务可以运行时，</a><span class='green'>空闲任务就会运行，这样 CPU就不会没事可做了，统计任务用于统计 CPU的利用率。</span><a href='../sentence_detail/278.htm' target='right' class='orange' >普通任务即为开发者创建的任务。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">109</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/279.htm' target='right' class='red' >每个任务都有5种状态，分别是就 绪 态、运 行 态、等 待 态、休 眠 态、中 断 态。</a><span class='green'>当任务控制块创建完后，任务就进入就绪态了，当任务得到 CPU而运行后，处于运行态，当任务进入休眠后，</span><a href='../sentence_detail/281.htm' target='right' class='orange' >就处于休眠态，当任务被挂起后就进入等待态，被中断的任务处于中断态。</a><span class='green'>各种状态的转换图如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">110</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-4 任务状态转换图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">111</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.2 任务的调度机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">112</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在嵌入式操作系统里，采用哪种调度策略，对操作系统的表现是有很大影响的，如果调度机制不完善，会影响系统的实时性。</span><a href='../sentence_detail/286.htm' target='right' class='orange' >嵌入式操作系统的调度算法可分为优先级法和时间片轮转法，优先级法又可分为非抢占式优先级法和抢占式优先级法，</a><span class='green'>时间片轮转法也可分为时间固定与可变两种方式[8]。</span><a href='../sentence_detail/288.htm' target='right' class='orange' >对于大多数的嵌入式实时操作系统，为了使系统能够快速响应外部突发事件，一般都采用基于优先级的算法[6]。</a><a href='../sentence_detail/289.htm' target='right' class='orange' >至于抢占式调度和非抢占式调度，由于在抢占式调度中，只要最高优先级的任务一旦就绪，就能得到 CPU的使用权，</a><a href='../sentence_detail/290.htm' target='right' class='orange' >而非抢占式调度中，当前任务会一直占用 CPU，直到其运行完成才会让出 CPU。</a><a href='../sentence_detail/291.htm' target='right' class='orange' >因此，为了确保系统的实时性，本课题所设计的嵌入式操作系统采用了按优先级的抢占式调度机制。</a>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：3/8页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
