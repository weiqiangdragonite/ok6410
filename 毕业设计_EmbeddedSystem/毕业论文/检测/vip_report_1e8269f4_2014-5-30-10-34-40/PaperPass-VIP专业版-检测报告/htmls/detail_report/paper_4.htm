<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：4/8页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">113</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/292.htm' target='right' class='orange' >采用按优先级的抢占式调度策略，系统总能优先运行最高优先级的就绪任务。</a><a href='../sentence_detail/293.htm' target='right' class='orange' >当一个任务在运行期间，使得另外一个更高优先级的任务进入了就绪状态，那么当前正在运行的任务的 CPU使用权就会被更高优先级的就绪任务所占用，</a><a href='../sentence_detail/294.htm' target='right' class='red' >如果是中断服务使一个更高优先级的任务进入了就绪状态，那么当中断完成后，并不会继续运行被中断的任务，</a><a href='../sentence_detail/295.htm' target='right' class='red' >而是去运行更高优先级的就绪任务。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">114</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/296.htm' target='right' class='orange' >如下图所示，两个不同优先级任务和一个中断服务的执行情况，当低优先级任务被中断后，</a><a href='../sentence_detail/297.htm' target='right' class='red' >系统进入中断服务子程序 ISR，中断服务子程序 ISR同时使一个更高优先级的任务进入就绪状态，</a><a href='../sentence_detail/298.htm' target='right' class='orange' >当中断服务程序执行完后，调度器会选择更高优先级的就绪任务来运行，而不是恢复被中断了的任务继续运行[9][10]。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">115</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/299.htm' target='right' class='red' >图3-5 优先级抢占式调度</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">116</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/300.htm' target='right' class='orange' >基于优先级的调度策略，每个任务都拥有一个由设计者按照任务的重要性来编排的优先级号。</a><a href='../sentence_detail/301.htm' target='right' class='orange' >任务的优先级设计是十分重要的，可以分为支持同优先级和不同优先级两种。</a><a href='../sentence_detail/302.htm' target='right' class='orange' >支持同优先级任务即多个任务可以拥有相同的优先级，而不同优先级是每个任务必须分配各不相同的优先级。</a><a href='../sentence_detail/303.htm' target='right' class='orange' >采用支持同优先级的方式比较适合现实情况，每个任务的优先级高低并不是绝对的，每个任务的地位基本相同，</a><span class='green'>并有一定的周期性[8]，但采用这种方式，任务的调度和任务的控制块就会变得相对复杂，</span><span class='green'>对于初做系统，可以采用相对简单的方式，更好的改进方式可以留到下一阶段来继续完成。</span><span class='green'>因此，本设计采用不同优先级的方式，虽然这种设计方法比较简单，但也是有比较多的问题，</span><span class='green'>其中就有优先级反转的问题，本设计里没有设计出针对此问题的解决方案，但已经有许多参考资料提出来了解决的方法，</span><span class='green'>这一部分也是留到下一阶段继续改进的地方。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">117</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/309.htm' target='right' class='orange' >采用不同优先级的方式，每个任务都拥有一个不同的优先级，因此，可以把任务的ID号等同于优先级号。</a><a href='../sentence_detail/310.htm' target='right' class='orange' >这里优先级号采用整数来表示，0为最高优先级，数字越小，优先级越高，高优先级的任务先运行，低优先级的任务后运行。</a><a href='../sentence_detail/311.htm' target='right' class='orange' >当系统进行调度时，可以在任务控制块链表中查找最高优先级就绪的任务来运行，</a><span class='green'>由于创建任务时，并不一定是按照任务的优先级来分别创建的，因此，如果在任务控制块链表中来查询，</span><a href='../sentence_detail/313.htm' target='right' class='orange' >其效率比较低，对系统的实时性有一定的影响。</a><span class='green'>所以，这里可以采用一个有序表，即一个一维数组，数组0表示0号任务，数组1表示1号任务，</span><a href='../sentence_detail/315.htm' target='right' class='orange' >以此类推，每个数组指向对应的任务控制块地址，即数组0是执行0号任务的任务控制块。</a><span class='green'>当进行查询时，就可以从数组0开始往下查找，如果数组N为空，表明不存在N号任务；</span><a href='../sentence_detail/317.htm' target='right' class='orange' >如果数组N存在，那么数组N所指向的任务控制块就是最高优先级就绪任务了。</a><span class='green'>模型图如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">118</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-6 优先级有序表</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">119</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/320.htm' target='right' class='orange' >这里采用顺序查找的算法虽然比较简单，但并不是最好的。</a><a href='../sentence_detail/321.htm' target='right' class='orange' >我们可以在创建任务时，根据任务的优先级顺序插入到任务控制块链表中相应的位置，</a><a href='../sentence_detail/322.htm' target='right' class='orange' >这样每次查找时就能更加快捷，但创建任务所花费的时间也会相对增加，</a><span class='green'>特别是当任务比较多的时候，这些改进也可留到下阶段改进。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">120</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.3 任务的创建</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">121</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/325.htm' target='right' class='orange' >每个任务都由任务控制块链表中的任务块进行管理，当系统运行后，会把每个空的任务控制块连接成一个链表，</a><a href='../sentence_detail/326.htm' target='right' class='orange' >称为空任务块控制链表，当需要创建任务时，便可从这个链表中拿出一个空的任务控制块，</a><span class='green'>来设置任务的相关信息。</span><a href='../sentence_detail/328.htm' target='right' class='orange' >所有创建好的任务控制块会连接到另外一个任务控制块链表中，当系统进行调度时，便会从这一链表中选出任务块来运行任务。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">122</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务的创建最关键就是设置任务的栈，本系统中每个任务都拥有一个固定的栈，栈空间的大小由开发者定义，毕竟不同开发板其内存资源也是不同的。</span><span class='green'>栈空间主要用于切换任务时，保存当前任务在CPU上寄存器的数据，以便将来恢复当前任务继续运行。</span><span class='green'>当任务首次创建时，PC寄存器会指向当前任务的函数入口地址，当函数被调度运行时，便可跳到对应的函数，开始执行程序。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">123</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>当设置好任务的栈后，还需要把任务块连接到任务控制块链表中，这样任务的状态就可以设置为就绪，等待系统调度运行了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">124</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/333.htm' target='right' class='orange' >任务链表和任务块的基本模型如下所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">125</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-7 任务链表图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">126</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.4 任务的挂起和恢复</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">127</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>每个普通任务都可以挂起任务自身或者其它任务，当任务被挂起时，就会处于挂起态，这时，不论任务的优先级是什么，都不会得到系统的调度运行。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">128</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>被挂起的任务只能通过其它任务来恢复，只要把被挂起任务的状态清掉，那么该任务就可继续参与到系统的调度中。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">129</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.5 任务删除</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">130</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务删除操作可以删除其它任务或者删除任务自身，为了让被删除的任务能够释放自身所占用的资源，</span><span class='green'>我们可以先发送一个删除任务的消息给对方，当对方收到这个消息后，就可以进行适当的步骤后再删除自身，</span><span class='green'>这种方法要比直接删除任务更安全、灵活。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">131</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.7 中断服务模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">132</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>中断服务模块主要为操作系统提供中断响应机制，当系统接收到外部中断请求后，会停止当前正在运行的任务，从而转到中断服务子程序进行中断处理。</span><span class='green'>本系统暂时只需要外部中断请求IRQ，因此只讲解外部中断的请求过程，对于其它中断比如快速中断FIQ等可以参考S3C6410芯片手册进行编写。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">133</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>每个任务需要打开中断后才能响应中断，在任务堆栈的初始化时，应当把每个任务的状态寄存器即 CPSR设为0 x0000001 F，</span><a href='../sentence_detail/346.htm' target='right' class='orange' >即处于系统工作模式并打开外部中断，这样当系统产生中断时，就会跳转到相应的中断处理函数。</a><a href='../sentence_detail/347.htm' target='right' class='orange' >本系统的主要中断处理函数有时钟定时器中断处理和按键中断处理。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">134</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>时钟定时器主要是完成系统在每个时钟节拍需要做的工作，我们首先需要设置系统时钟的节拍，比如系统时钟节拍为10ms，即每秒中断10次。</span><span class='green'>这里需要根据S3C6410芯片手册，设置相应的时钟寄存器，把设置的值写入到相应的位即可。</span><span class='green'>由于 ARM11采用的中断向量的方式来设置中断，所以中断设置比较简单，只需把中断的处理函数地址写到对应的向量位，</span><a href='../sentence_detail/351.htm' target='right' class='orange' >那么当中断产生时，就会自动进入中断处理函数，进行中断处理。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">135</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/352.htm' target='right' class='orange' >时钟定时器的中断处理函数主要完成的工作为：</a><span class='green'>给系统的时钟计数器加1，然后遍历任务控制链表，把所有延时任务的延时器减1，如果延时任务的延时器变为0，还要将该任务的延时状态清零。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">136</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>处理中断的函数基本都是使用ARM汇编来完成，主要是进入中断前，需要保存CPU的寄存器数据到当前任务的栈空间中，然后在进入中断处理函数。</span><a href='../sentence_detail/355.htm' target='right' class='orange' >退出中断后，需要把任务栈中的寄存器数据恢复到处理器中，从而使得任务能继续运行。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">137</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>按键中断也是首先设置好相应的中断位，然后设置中断处理函数的地址，当有按键按下时，系统就会跳到对应的按键的中断处理函数。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">138</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.8 时间管理模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">139</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/358.htm' target='right' class='orange' >时间管理模块可以提供任务的延时和系统时钟节拍的功能。</a><span class='green'>任务的延时主要根据时钟节拍来计算出任务所需延时的时钟节拍数，本系统的时钟节拍为10，即1秒会进行10次中断，时间片为100ms。</span><span class='green'>如果任务需要延时1秒，那么延时的节拍数即为10。</span><span class='green'>任务进入延时后，系统应当重新引发一次调度，运行下一个就绪任务。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">140</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>每次时钟中断，系统都会检查任务块，对于有延时的任务块，系统会减去1个延时节拍数，当延时节拍数变为0，那么任务块的延时状态就会清零。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">141</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>此外，还需记录系统从开始运行到至今已经经过多少个时钟节拍，因此，系统还有一个时钟计数器，每次时钟节拍中断时都会加1。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">142</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.9 内存管理模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">143</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/365.htm' target='right' class='orange' >内存管理功能是操作系统内核中一个重要的功能，本小型嵌入式操作系统提供一个比较简单的内存管理功能，</a><a href='../sentence_detail/366.htm' target='right' class='orange' >任务能在运行时申请内存空间，当任务不需要这些空间时，可以释放归还给操作系统。</a><span class='green'>内存管理的技术比较多，从操作系统教程就可知道有地址空间与重定位、分区管理、分页技术、虚拟存储管理等等。</span><a href='../sentence_detail/368.htm' target='right' class='orange' >其中分区的管理算法简单，易于实现，但碎片问题严重，内存利用率低[11]。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">144</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本系统采用比较简单的固定分区法来实现内存的管理。</span><a href='../sentence_detail/370.htm' target='right' class='red' >固定分区法就是内存中分区的个数固定不变，各个分区的大小固定不变，根据大小的不同还可分为等分方式和差分方式，</a><a href='../sentence_detail/371.htm' target='right' class='orange' >所谓等分，就是各个分区大小相同，所谓差分，就是分区具有不同大小[12]。</a><span class='green'>利用等分方式，实现方法简单，需要处理的开销也很小，但缺点也很明显，任务申请的内存空间一定要在分区的大小之内，否则将会引起灾难性的结果。</span><span class='green'>对于更好的分区方法，将留到下阶段的改进。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">145</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>采用固定分区法，我们可以通过定义一个二维数组就能实现内存分区，比如一个8位的数组 MxN，</span><a href='../sentence_detail/375.htm' target='right' class='orange' >内存分区的大小为8* M* N个字节，总共可以分为 M个内存块，每个内存块有 N个字节，</a><a href='../sentence_detail/376.htm' target='right' class='orange' >每次任务申请的内存都需要小于 N个字节。</a><span class='green'>如下图所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">146</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-8 固定分区</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">147</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>这种分区方法虽然比较粗糙，内存的利用率低，但实现简单，开销小，实时性也较好。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">148</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/380.htm' target='right' class='orange' >有了内存分区后，我们还需要一个内存控制块来管理内存分区里的内存块，实现真正的内存分配。</a><a href='../sentence_detail/381.htm' target='right' class='red' >内存控制块需要设置内存分区的起始地址、内存块的大小、内存块的数量，已经分配出去的内存块数量等信息。</a><span class='green'>对于各个内存块，我们需要把它们连接成一个链表，那么分配内存时，就可直接在链表中取出该内存块给任务，</span><a href='../sentence_detail/383.htm' target='right' class='orange' >任务释放内存时，只需将该内存块连接回链表中即可。</a><span class='green'>如下图所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">149</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/385.htm' target='right' class='red' >图3-9 内 存 控 制块和内 存 分区的关系</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">150</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.10 本章小结</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_8.htm">尾页</a>
页码：4/8页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
