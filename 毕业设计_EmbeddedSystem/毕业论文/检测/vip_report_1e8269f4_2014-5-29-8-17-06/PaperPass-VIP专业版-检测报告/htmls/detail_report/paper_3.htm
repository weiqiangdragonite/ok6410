<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：3/10页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">74</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>中断服务功能。</span><a href='../sentence_detail/178.htm' target='right' class='orange' >中断服务的功能模块是本操作系统的重点，也是难点之一。</a><span class='green'>中断服务涉及开发板相关的底层操作，大部分采用ARM汇编来编写中断服务的进入和退出。</span><a href='../sentence_detail/180.htm' target='right' class='orange' >而中断服务子程序（Interrupt Service Routines，ISR）一般都是采用简单的C语言来编写，主要完成在中断时进行的操作。</a><a href='../sentence_detail/181.htm' target='right' class='orange' >同时任务的调度也是由中断服务来完成，包括任务数据的保存和恢复。</a><span class='green'>可以说，只要把中断服务功能设计好，多任务的调度已经不成问题了，一个操作系统的基本雏形已经做好了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">75</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>时间管理功能。</span><span class='green'>这里的时间管理功能主要用于系统的时间节拍，可以用来对任务进行延时，也可用来获取系统运行的总节拍数。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">76</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>内存管理功能。</span><span class='green'>这里是比较简单的内存管理，主要采用固定分区法，在预先分配好的二维数组里进行内存分配。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">77</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.2 系统的总体结构</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">78</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/188.htm' target='right' class='orange' >系统的总体结构主要包括整个嵌入式操作系统的引导启动、硬件的初始化、操作系统的运行等。</a><a href='../sentence_detail/189.htm' target='right' class='orange' >本论文主要把整个系统分割成4个模块：</a><a href='../sentence_detail/190.htm' target='right' class='orange' >引导启动模块、系统更新模块、串口通信模块、操作系统模块。</a><a href='../sentence_detail/191.htm' target='right' class='orange' >其中操作系统模块根据系统的基本功能又细分为任务管理模块、时间管理模块、中断服务模块和内存管理模块。</a><span class='green'>总体的结构模块如下图所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">79</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>引导启动模块。</span><span class='green'>这个模块的主要功能是引导开发板的启动，主要是以ARM汇编为主。</span><span class='green'>主要包括设置ARM异常向量的地址、设置外设接口的地址、关闭看门狗、设置CPU的主频、初始化SDRAM和NAND Flash、把代码复制到SDRAM中等。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">80</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统更新模块。</span><span class='green'>由于操作系统不可能一次编写，就能成功运行所有功能，因此需要不停的往开发板重复烧写新的操作系统程序。</span><a href='../sentence_detail/198.htm' target='right' class='orange' >由于每次烧写目标程序时都需要使用 u- boot在 Windows下才能把程序写进 NAND Flash上，</a><span class='green'>比较麻烦，而且在 Linux下没有相关的 Linux驱动，因此，本课题里设计了一段能自行更新 NAND Flash上目标程序的代码，</span><span class='green'>并集合到系统上。</span><span class='green'>这个系统更新模块主要采用串口通信来获取新的目标程序，系统引导启动后就能直接选择更新系统或者运行系统，即方便又简单。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">81</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>串口通信模块。</span><span class='green'>这里的串口通信模块主要方便调试，开发板通过串口与主机进行通信，可以让开发板输出相关的信息，然后在主机上显示，而且这个串口通信模块还包括主机上的串口通信软件。</span><span class='green'>这个通信软件是本课题里自行编写的软件，其中串口通信方面采用了第三方写的插件，而且这个软件结合系统更新模块，</span><span class='green'>主要是通过串口来传输二进制文件来更新开发板上的系统程序代码。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">82</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>操作系统模块。</span><a href='../sentence_detail/207.htm' target='right' class='red' >本模块包括任务管理模块、中断服务模块、时间管理模块和内存管理模块。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">83</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/208.htm' target='right' class='red' >图3-1 嵌入式操作系统的总体模块图</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">84</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.3 引导启动模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">85</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>引导启动模块是整个嵌入式系统的首要模块，主要功能就是引导并启动操作系统，跟bootloader类似。</span><a href='../sentence_detail/211.htm' target='right' class='orange' >整个引导启动模块所完成的功能就是初始化相关的硬件，然后跳转到系统启动界面。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">86</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>引导启动模块往往与芯片和开发板紧密结合，因此不同的开发板其实现过程往往不同，但其思路基本是一样的，</span><a href='../sentence_detail/213.htm' target='right' class='orange' >下面就以 OK6410开发板为例，讲解其引导模块的设计过程。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">87</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/214.htm' target='right' class='red' >设置异常处理函数的入口地址。</a><a href='../sentence_detail/215.htm' target='right' class='orange' >根据 ARM的体系结构可知，地址0 x0000000到0 x0000001 F是 ARM异常向量的入口地址，</a><a href='../sentence_detail/216.htm' target='right' class='orange' >当 ARM芯片启动或复位后，系统会自动从0 x00000000的地址处开始执行程序，因此我们需要在0 x00000000处设置一条跳转指令，</a><a href='../sentence_detail/217.htm' target='right' class='orange' >跳转到程序的初始化处，其余的异常向量入口地址需要填写相应的异常处理函数的入口地址，</a><a href='../sentence_detail/218.htm' target='right' class='orange' >以便异常发生时，系统跳转到相应的处理函数处。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">88</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>初始化相关的硬件。</span><a href='../sentence_detail/220.htm' target='right' class='orange' >当系统跳到初始化处后，就可以开始初始化相关的硬件了。</a><span class='green'>这里首先要禁止所有的IRQ和FIQ中断，然后根据S3C6410的芯片手册[4]，还需设置外设寄存器的地址后才能设置相关寄存器的值。</span><span class='green'>接着是关闭看门狗，大多数嵌入式芯片都有看门狗的功能，因此需要关闭看门狗，不然系统会每隔一段时间就会自动重启。</span><span class='green'>然后初始化其它的硬件，比如CPU的频率，SDRAM和NAND Flash，这些寄存器的设置只需根据相关的芯片手册来进行初始化即可。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">89</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/224.htm' target='right' class='orange' >（3）初始化CPU频率、SDRAM和NAND Flash后，还需要重定位代码。</a><span class='green'>由于 S3 C6410芯片启动后会自动从 NAND Flash中复制8 KB的数据到芯片的 SRAM中运行，</span><span class='green'>但往往一个操作系统的大小会超过8 KB，因此，我们需要把程序复制到内存 SDRAM上，</span><span class='green'>然后从 SRAM跳到 SDRAM中继续运行，这一步骤就是重定位。</span><a href='../sentence_detail/228.htm' target='right' class='orange' >重定位只需将NAND Flash中的代码段TEXT和数据段DATA复制到SDRAM中，最后清零BSS段即可。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">90</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/229.htm' target='right' class='orange' >重定位后，就准备跳到SDRAM中继续执行代码了。</a><span class='green'>这里一般是跳到main函数开始执行主程序，但在本系统中，由于存在系统更新模块，因此是首先跳入到更新函数，然后再执行main函数。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">91</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后是异常处理程序的编写。</span><a href='../sentence_detail/232.htm' target='right' class='orange' >由于发生异常后，系统会跳到异常向量地址处，执行异常向量地址处的函数。</a><a href='../sentence_detail/233.htm' target='right' class='orange' >在准备处理异常前，首先要保存用户现场，即将CPU相应的寄存器入栈。</a><span class='green'>由于ARM存在流水线的问题，因此寄存器LR的返回地址不一定是正确的返回地址，需要根据哪种异常来进行修改。</span><a href='../sentence_detail/235.htm' target='right' class='orange' >接着跳到异常处理程序，当异常处理完毕后，恢复用户现场。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">92</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>ARM有7种异常，由于复位异常不需编写异常处理程序，所以实际只需编写6个异常处理的函数。</span><span class='green'>但因为本系统中只用到外部中断IRQ，所以只编写了IRQ的处理函数，其余5个异常处理程序，开发者可根据实际需要进行编写。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">93</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.4 串口通信模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">94</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>串口通信模块对于嵌入式系统的调试是非常重要的，本模块可分为主机和开发板两部分，</span><a href='../sentence_detail/240.htm' target='right' class='orange' >开发板将相关的信息通过串口发送到主机上，主机通过串口接收到信息后显示出来，</a><a href='../sentence_detail/241.htm' target='right' class='orange' >同时主机可向开发板发送数据，开发板也可接收主机发来的数据。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">95</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>绝大多数的开发板都有一个串口插座，OK6410开发板有一个DB9的串口母座，可直接与计算机的串口进行连接通信。</span><a href='../sentence_detail/243.htm' target='right' class='orange' >要进行串口的通信，首先需要设置开发板的串口信息，比如串口波特率，数据位，停止位，校验位等。</a><a href='../sentence_detail/244.htm' target='right' class='orange' >相关的设置可根据芯片手册来设置相应的寄存器。</a><span class='green'>要通过开发板的串口发送数据，只需将该数据逐位写到相应的寄存器便可发送到PC的串口上，接收数据也是类似，从相应的寄存器去读取数据。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">96</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>开发板上实现基本的串口通信比较简单，而在主机上，比如 Windows系统，往往有较多的串口通信软件，</span><span class='green'>但由于本系统存在系统更新模块，而系统的更新，是通过串口来获取新的程序代码来实现的，</span><span class='green'>因此，本系统还实现了一个能够发送二进制文件的串口通信软件。</span><span class='green'>该软件基于Qt来开发，串口通信的实现主要通过第三方的插件来实现，除了基本的串口通信外，还能配合系统的更新模块来发送更新系统的程序，简单方便。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">97</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.5 系统更新模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">98</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/251.htm' target='right' class='orange' >当程序进入系统更新模块后，就可以选择更新系统程序代码或者运行系统。</a><span class='green'>系统更新模块主要用到串口通信，利用串口通信来接收主机的系统更新代码，把代码复制到NAND Flash上，然后重启系统，就能运行新的系统程序了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">99</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统更新模块的难点主要在于接收新的代码和把代码写入到NAND Flash上。</span><span class='green'>本系统从内存地址0x5FC00000（离内存尾端4MB）处开始存放系统的更新代码，当接收完代码数据后，然后在将数据写入到NAND Flash上。</span><a href='../sentence_detail/255.htm' target='right' class='orange' >NAND Flash上的数据读写需要根据NAND Flash的芯片手册来操作。</a><a href='../sentence_detail/256.htm' target='right' class='orange' >这里还要注意S3C6410上的NAND Flash陷阱，OK6410开发板的NAND FLash是以页为单位进行读写的，每页有4KB是用来存储数据，218个字节来存放校验和等信息。</a><span class='green'>按照原理，S3C6410处理器是从前两页读取8KB的数据到SRAM中，但其实并不是这样的。</span><span class='green'>S3 C6410会从前4页，每页读取2 KB，总共8 KB的数据到 SRAM中，所以，当把系统代码更新时，</span><a href='../sentence_detail/259.htm' target='right' class='orange' >并不能直接把数据从 NAND Flash的第一页开始写下去，</a><span class='green'>而是需要把8 KB数据写到4页里，</span><a href='../sentence_detail/261.htm' target='right' class='orange' >第2到第5页的前2 KB数据与前一页的后2 KB数据相同，</a><span class='green'>如下图所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">100</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-2 NAND Flash前4页的数据写法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">101</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>至此，关于开发板从启动到准备运行操作系统，本设计把这一阶段分为了三个模块来讲解，</span><span class='green'>其中串口通信模块和系统更新模块并不是必须的，但对于系统的调试和更新是非常方便的，</span><span class='green'>如果到了应用正式部署的时候，可以选择性的删除。</span><span class='green'>这三个模块与开发板的硬件紧密结合，不同的开发板其实现过程也是不同的，因此这里只是简单的介绍了在OK6410下的设计过程，其它的需要根据实际的开发板进行相应的移植和修改。</span><a href='../sentence_detail/268.htm' target='right' class='orange' >当系统的环境准备好后，就可以开始载入操作系统内核并开始运行了。</a>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：3/10页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
