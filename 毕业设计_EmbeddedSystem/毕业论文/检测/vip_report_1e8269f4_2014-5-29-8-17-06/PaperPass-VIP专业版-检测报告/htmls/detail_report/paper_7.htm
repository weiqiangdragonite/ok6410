<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_6.htm">上一页</a>
<a class="pagelink" href="paper_8.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：7/10页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">232</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-22 interrupt_switch_task()函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">233</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>中断服务模块还有一个重要的功能，就是能提供开中断或关中断功能，系统默认是打开中断的，</span><span class='green'>但有时一些代码不能受到中断的影响，因此需要关闭中断，那些不希望被中断的代码段叫做临界段。</span><span class='green'>打开和关闭中断涉及到ARM指令，因此这部分代码是通过ARM汇编来编写的。</span><a href='../sentence_detail/543.htm' target='right' class='orange' >本系统通过enter_critical()和exit_critical()两个函数来退出和打开中断，这两个函数其实是用宏定义来实现，代码如下。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">234</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4-23 退出和打开中断宏定义</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">235</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>退出中断首先需要保存CPSR状态寄存器，由save_cpsr()来完成，然后关闭中断即可。</span><span class='green'>恢复中断由restore_cpsr()来完成，只需要恢复原先保存的CPSR寄存器即可。</span><span class='green'>代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">236</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/548.htm' target='right' class='orange' >图4-24 保存和恢复CPSR寄存器代码</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">237</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.5 时间管理模块的实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">238</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/550.htm' target='right' class='orange' >时钟中断服务程序为 time_ tick()，该函数的主要功能是给时间计数器计数，</a><a href='../sentence_detail/551.htm' target='right' class='orange' >接着遍历所有任务控制块，如果该任务有延时，就把延时计数器减1，并判断计数器是否减为0，</a><span class='green'>如果是，还需要把该任务的延时状态给清零。</span><span class='green'>代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">239</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-25 time_tick()函数代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">240</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本系统提供多个函数接口给开发者调用，比如 delay()函数，能够让当前任务休眠指定个时钟节拍，</span><span class='green'>sleep()函数，让当前任务休眠指定的秒数， msleep()让任务休眠指定的毫秒数，</span><span class='green'>sleep_ hmsm()能用时、分、秒、毫秒来作为传递参数进行休眠延时。</span><span class='green'>其中 sleep()、 msleep()、 sleep_ hmsm()函数都是先把时间转化为毫秒数，</span><span class='green'>然后计算出休眠的时间节拍后，再调用 delay()函数来进入休眠，所以 delay()函数是所有休眠函数的最终调用函数，</span><span class='green'>delay()函数的核心代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">241</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-26 delay()函数代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">242</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>休眠函数msleep()的代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">243</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-27 msleep()函数代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">244</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>剩下的sleep()和sleep_hmsm()函数代码都是比较简单，都是把休眠的时间转化为毫秒，再调用msleep()就可以了。</span><a href='../sentence_detail/565.htm' target='right' class='orange' >任务进行休眠后，会进行一次新的任务调度，从而运行最高优先级就绪任务，</a><a href='../sentence_detail/566.htm' target='right' class='orange' >延时任务会在时间中断服务程序里减去延时计数器，当延时计数器减为0时，</a><span class='green'>如果任务没有被挂起，那么该任务就会再次成为就绪任务，等待调度。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">245</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务也可以取消延时，由其它任务进行调用cancel_delay()函数从而取消被延时的任务，并进行一次新的调度。</span><span class='green'>取消延时的函数如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">246</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-28 cancel_delay()函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">247</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.6 内存管理模块的实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">248</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/572.htm' target='right' class='orange' >内存控制块主要用来记录内存分区的状态信息，其定义如下所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">249</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-29 内存控制块的定义</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">250</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/574.htm' target='right' class='orange' >内存控制块中 mem_ addr指向内存分区的起始地址， mem_ free_ list指向下一个内存块地址， block_ len表示内存块的长度，</a><a href='../sentence_detail/575.htm' target='right' class='orange' >即大小， num_ blocks表示内存块的个数， num_ free表示空闲的内存块的数目。</a><span class='green'>当系统初始化时，首先会把内存分区内的各个内存块连成一个链表，当任务需要内存块时，就从链表中取出内存块，返回给任务。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">251</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-30 create_mem()函数核心代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">252</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>核心代码如上图所示，以定义的 u8 array[10][50]为例，内存分区就是 array这个数组，</span><span class='green'>其中有10个内存块，每个内存块大小为50个字节，所以每次分配内存，就是把 array[0]、 array[1]、 array[2]的地址返回给调用者。</span><span class='green'>因此，还需要把全部内存块连接在一起，这里可以把 array[0]指向 array[1]，</span><a href='../sentence_detail/581.htm' target='right' class='orange' > array[1]指向 array[2]，以此类推，然后内存控制块的 mem_ addr指向内存分区的首地址，</a><a href='../sentence_detail/582.htm' target='right' class='orange' >也就是 array， mem_ free_ list指向内存块，每申请一次内存， mem_ free_ list就指向下一个内存块，</a><span class='green'>从而达到分配内存的目的。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">253</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/584.htm' target='right' class='orange' >当内存分区创建好后，就可以在任务里申请和释放内存空间了。</a><span class='green'>这里需要要注意，申请内存空间，并不像一般程序里申请多少个字节就能获取多少个字节的空间，在本嵌入式操作系统里，</span><span class='green'>申请的空间必须小于或等于内存块的大小，如果定义的内存分区为 u8 array[10][50]，</span><span class='green'>那么每次申请的内存空间绝对不能超过50个字节，而且只能申请10次内存空间。</span><a href='../sentence_detail/588.htm' target='right' class='orange' >如果申请的空间超过内存块的大小，那么只会返回NULL指针。</a><span class='green'>申请内存块使用get_mem()函数，该函数首先判断申请内存的大小，然后判断该内存分区是否还有空余的内存块，如果有，则把该内存块的地址返回给调用者。</span><span class='green'>具体代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">254</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-31 get_mem()函数代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">255</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/592.htm' target='right' class='orange' >释放内存的函数为free_mem()，该函数首先把释放的内存块指向内存分区里的空余内存块，然后把mem_free_list指向该内存块，从而达到归还到内存分区中。</a><span class='green'>释放内存空间代码如下。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">256</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-32 free_mem()函数代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">257</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.7 本章小结</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">258</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/596.htm' target='right' class='orange' >本章主要详细讲解了操作系统模块的实现代码，也就是整个小型嵌入式操作系统的内核代码，</a><span class='green'>包括系统变量的定义，任务的创建和调度等功能的实现，中断服务功能的实现，时间管理和内存管理的功能实现，</span><a href='../sentence_detail/598.htm' target='right' class='orange' >这四个模块组合起来，就是一个简单操作系统的基本实现。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">259</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统测试</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">260</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1 测试环境</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">261</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）主机配置</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">262</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>处理器：</span><span class='green'>Intel Core i3-3217U，1.8GHz</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">263</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>内存：</span><span class='green'>4GB</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">264</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>硬盘：</span><span class='green'>320GB</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">265</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>操作系统：</span><span class='green'>Windows 7旗舰版</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">266</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）开发板配置</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">267</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>芯片：</span><span class='green'>三星S3C6410，ARM 11，533 MHz</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">268</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>内存：</span><span class='green'>DDR 256MB</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">269</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>NAND Flash：</span><span class='green'>4GB</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">270</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2 测试结果及分析</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">271</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/618.htm' target='right' class='orange' >下面针对操作系统的各个功能模块进行测试。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">272</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）任务管理模块</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">273</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/620.htm' target='right' class='red' >表5-1 任务管理模块的测试用例和结果</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">274</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/621.htm' target='right' class='orange' >测试用例操作描述预期结果实际结果测试状态</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">275</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/622.htm' target='right' class='orange' >1-1使用任务创建函数，分别创建2个任务，并显示出任务的栈地址和函数的入口地址。</a><a href='../sentence_detail/623.htm' target='right' class='orange' >创建相应优先级的任务，并打印出该任务的栈地址和函数入口地址。</a><span class='green'>如图5-1所示通过</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">276</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/625.htm' target='right' class='orange' >1-2进行2个任务的调度，每个任务打印出各自的优先级号后休眠1秒。</a><a href='../sentence_detail/626.htm' target='right' class='orange' >2个任务各自打印自己的优先级号，然后延时1秒。</a><span class='green'>如图5-2所示通过</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_6.htm">上一页</a>
<a class="pagelink" href="paper_8.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：7/10页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
