<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_5.htm">上一页</a>
<a class="pagelink" href="paper_7.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：6/10页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">179</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>arm-none-eabi-gcc -v</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">180</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>如果出现如下图2-7的GCC版本号，那么基本的开发环境就搭建好了，可以开始编写和编译ARM应用程序了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">181</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/451.htm' target='right' class='red' >图4-1 ARM交叉编译工具链版本号</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">182</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2 任务管理模块的实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">183</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/453.htm' target='right' class='red' >4.2.1 任务控制块的定义及初始化</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">184</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/454.htm' target='right' class='orange' >根据第3章任务控制块的设计，具体的代码实现如下图所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">185</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-2 任务控制块的定义</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">186</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/456.htm' target='right' class='orange' >其中tcb_stk_ptr就是每个任务的栈指针，该栈指针指向每个任务的栈地址；</a><a href='../sentence_detail/457.htm' target='right' class='red' >tcb_prio是任务的优先级号，即任务号；</a><span class='green'>tcb_next和tcb_prev分别指向下一个和前一个任务控制块，task_status是任务的状态，tcb_delay为任务的延时节拍，tcb_del_req是任务的删除标志。</span><span class='green'>其中定义了3种任务状态，就绪、延时和挂起，定义如下图所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">187</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-3 任务状态的定义</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">188</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/461.htm' target='right' class='orange' >任务控制定义好后，还需要定义任务控制块的链表指针、任务块的变量，当前运行任务块的指针、最高优先级就绪任务的指针，</a><a href='../sentence_detail/462.htm' target='right' class='red' >优先级有序表等，如下图所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">189</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/463.htm' target='right' class='orange' >图4-4 任务控制块的相关变量</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">190</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/464.htm' target='right' class='orange' >当定义好任务控制块的所有变量后，需要把空任务块连接成空任务块控制链表，主要代码如下图所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">191</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/465.htm' target='right' class='orange' >图4-5 空任务块链表</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">192</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.3.2 任务的创建</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">193</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/467.htm' target='right' class='orange' >任务控制块初始化后，系统会创建系统任务，然后才会创建开发者定义的普通任务。</a><a href='../sentence_detail/468.htm' target='right' class='orange' >系统和普通任务都是通过create_task()函数来创建。</a><a href='../sentence_detail/469.htm' target='right' class='orange' >create_task()需要四个参数，分别是任务函数的入口地址，任务函数的参数，栈顶地址和任务的优先级号。</a><a href='../sentence_detail/470.htm' target='right' class='orange' >首先函数会判断任务的优先级号是否在正常范围内，即0到最小优先级号之间，接着判断该任务号是否已经被其它任务申请了，</a><span class='green'>这里是通过 os_ tcb_ prio_ table[ prio]来判断，如果为 NULL，则说明此任务号还没被使用，</span><a href='../sentence_detail/472.htm' target='right' class='orange' >接着会初始化该任务的栈和任务块，代码如下图所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">194</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-6 create_task()函数部分代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">195</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中 init_ task_ stack()和 init_ tcb()是创建任务的重点函数，</span><span class='green'>init_ task_ stack()用来初始化任务的栈空间，即从栈顶地址分配寄存器空间，</span><a href='../sentence_detail/476.htm' target='right' class='orange' >用于保存任务调度时的任务现场数据，代码如下图所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">196</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-7 init_task_stack()函数代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">197</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/478.htm' target='right' class='orange' > init_ tcb()函数主要是从 os_ tcb_ free_ list里取出一个空任务块，把它连接到任务控制块链表中，</a><a href='../sentence_detail/479.htm' target='right' class='orange' >接着设置任务相应的值后，该任务就处于就绪运行的状态了，代码如下。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">198</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-8 init_tcb()函数部分代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">199</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>当创建的任务进入就绪状态后，会返回到 create_ task()函数中继续运行，此时 create_ task()函数会判断系统是否已经在运行，</span><a href='../sentence_detail/482.htm' target='right' class='orange' >如果系统已经运行，则会进入任务调度函数进行任务调度。</a><span class='green'>如果系统还没有开始运行，则会返回，直到start_os()函数运行后才开始调度多任务。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">200</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.3.3 多任务的调度</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">201</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统开始运行前，会执行start_os()函数，才会开始执行多任务的调度。</span><a href='../sentence_detail/486.htm' target='right' class='orange' >start_os()函数首先从优先级有序表找出就绪的最高优先级任务，然后开始运行就绪任务，代码如下。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">202</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-9 start_os()函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">203</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/488.htm' target='right' class='orange' >其中，sched_new()函数负责找出最高优先级就绪的任务，代码如下。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">204</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-10 sched_new()函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">205</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/490.htm' target='right' class='orange' >查找最高优先级就绪任务的算法比较简单，直接从 os_ tcb_ prio_ table开始从0往下找，</a><a href='../sentence_detail/491.htm' target='right' class='orange' >因为优先级越高的任务，其任务号越低，所以，只要 os_ tcb_ prio_ table[ prio]不为 NULL，</a><span class='green'>就能知道该任务号是存在的，所以我们就可以通过该任务的 task_ status来判断是否为就绪，</span><span class='green'>如果就绪，则把 os_ prio_ high_ ready设为该任务号。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">206</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>start_task()函数运行就绪任务，将任务从栈寄存器中恢复数据，就可以开始运行了，本函数通过ARM汇编来编写，代码如下图4-11和4-12所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">207</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-11 start_task()函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">208</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-12 restore_task()函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">209</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统开始运行后，就由sched()函数来专门负责任务的调度了，比如正在运行的任务进入延时后，就会调用sched()函数来重新进行任务的调度运行，代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">210</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-13 sched()函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">211</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/499.htm' target='right' class='orange' >该函数首先判断当前运行的任务与最高优先级的就绪任务是否相同，如果不相同，则进行任务的调度，选择最高优先级就绪的任务来运行。</a><span class='green'>切换任务由 switch_ task()函数来完成，该函数使用 ARM汇编来编写，主要先保存当前任务的数据，</span><a href='../sentence_detail/501.htm' target='right' class='orange' >然后恢复最高优先级就绪任务的栈寄存器数据即可恢复现场来运行，主要代码如下。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">212</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-14 switch_task()函数主要代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">213</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务的调度主要由选择最高优先级就绪任务和切换任务这两部分来完成，本设计只是用比较简单的算法来实现基本任务调度原理，</span><span class='green'>因此没有复杂的调度算法，而切换任务只需首先把当前任务的数据保存起来，然后把最高优先级就绪任务的地址保存到当前栈指针 SP处，</span><span class='green'>就能由 ldr指令恢复现场数据了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">214</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.3.4 任务的挂起和恢复</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">215</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/507.htm' target='right' class='orange' >挂起任务，就能让任务停止运行。</a><a href='../sentence_detail/508.htm' target='right' class='orange' >挂起任务的函数为suspend_task()，调用该函数，可以挂起任务自身，也可以挂起其它有效任务。</a><a href='../sentence_detail/509.htm' target='right' class='orange' >如果需要挂起任务自身，传递的参数为OS_PRIO_SELF，其它任务只需传递相应的任务号即可。</a><span class='green'>该函数会改变任务的状态为TASK_SUSPEND，从而使它不能就绪而停止运行。</span><a href='../sentence_detail/511.htm' target='right' class='orange' >如果挂起的任务是当前任务自身，改变任务状态后，还会调用sched()来进行重新的任务调度，选择最高优先级就绪任务来进行运行。</a><span class='green'>基本代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">216</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-15 任务挂起函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">217</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/514.htm' target='right' class='orange' >任务的恢复只能通过其它任务来恢复被挂起的任务，函数为resume_task()。</a><span class='green'>该函数将任务状态的TASK_SUSPEND清零，如果该任务没有设置延时状态，该位清零就会变成就绪状态，也就是TASK_READY，同时会进行新的任务调度，代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">218</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-16 任务恢复函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">219</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务的挂起和恢复相对简单，只要设置任务状态的相应位为对应的状态即可，设置后只要调用sched()函数就能进行新的任务调度了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">220</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.3.5 任务的删除</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">221</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务删除可以删除其它任务或者删除任务自身，首先要调用delete_task_request()来发送删除任务的消息，被删除任务接受到删除消息后，调用delete_task()来删除任务自身。</span><span class='green'>删除任务首先把任务挂起，并把延时时间设为0，避免被调度。</span><a href='../sentence_detail/521.htm' target='right' class='orange' >接着把该任务块从os_tcb_list中归还到os_tcb_free_list中，再引发新的任务调度。</a><span class='green'>代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">222</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-17 delete_task_request()部分代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">223</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-18 delete_task()部分代码</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">224</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.4 中断服务模块的实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">225</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/526.htm' target='right' class='orange' >由于系统启动时，本设计就已经设置外部中断服务程序的入口地址，所以当发生外部中断IRQ后，系统会跳转到irq_isr函数处执行中断处理。</a><a href='../sentence_detail/527.htm' target='right' class='orange' >执行中断处理前，首先需要保存任务现场，然后跳转到中断处理程序处理中断，处理完毕后，退出中断，恢复任务。</a><span class='green'>核心代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">226</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-19 irq_isr函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">227</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/530.htm' target='right' class='orange' >其中handle_irq用来跳到开发者定义的中断处理函数，代码如下。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">228</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-20 handle_irq函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">229</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>退出中断，由exit_interrupt函数来完成。</span><span class='green'>退出中断前，该函数会进行一次任务调度，如果没有更高优先级就绪的任务，那么会恢复被中断的任务接着运行，否则会去运行更高优先级就绪的任务，代码如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">230</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-21 exit_interrupt函数</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">231</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/535.htm' target='right' class='orange' >如果没有更高优先级就绪任务，那么函数就会返回到 irq_ isr函数处，</a><a href='../sentence_detail/536.htm' target='right' class='orange' >接着恢复被中断的任务去运行，如果此时有了更高优先级就绪的任务，</a><a href='../sentence_detail/537.htm' target='right' class='orange' >那么就会执行 interrupt_ switch_ task()函数来运行更高优先级就绪任务。</a><span class='green'>interrupt_switch_task()首先得出更高优先级就绪任务的任务块指针，接着恢复寄存器数据就能开始运行了，代码比较简单，如下所示。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_5.htm">上一页</a>
<a class="pagelink" href="paper_7.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：6/10页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
