<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：4/10页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">102</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6 任务管理模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">103</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.1 任务的定义及其结构</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">104</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/271.htm' target='right' class='orange' >人们在现实生活中遇到一个大而复杂的问题时，往往会把这个大问题分解成多个简单和容易解决的小问题。</a><span class='green'>在实际编程中，当面对大的应用程序时，我们也会把它编写成一个个小程序来完成目的。</span><a href='../sentence_detail/273.htm' target='right' class='red' >这种方法即能提高CPU的利用率，同时又加快了程序的执行速度。</a><span class='green'>由于嵌入式系统都是与具体的应用紧密结合的，都是针对解决某一类问题，因此可以把这一类问题分解成许多小问题，再交给操作系统来进行处理。</span><span class='green'>利用这种思路，在嵌入式操作系统里，就可以把每个大问题转化为多个任务，每个任务都有自己相应的工作函数，</span><a href='../sentence_detail/276.htm' target='right' class='orange' >由操作系统来进行调度和管理，这样就能实现一个多任务的操作系统了。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">105</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/277.htm' target='right' class='red' >一个任务，也称作一个线程，是一段简单的程序，该程序可以任务 CPU完全只属于该程序自己，</a><a href='../sentence_detail/278.htm' target='right' class='red' >当某个问题分解成多个任务后，每个任务都是属于整个应用的某一部分，每个任务都被赋予一定的优先级，</a><span class='green'>有自己独立的栈空间，彼此独立运行[6]。</span><a href='../sentence_detail/280.htm' target='right' class='orange' >典型的任务都是一个无限循环的函数，由任务控制块来进行管理，一般都包括任务的栈地址，任务的优先级，任务的状态等信息[7]。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">106</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本论文设计的嵌入式操作系统由任务控制块链表来管理各个任务，任务的基本模型如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">107</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-3 任务链表</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">108</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/283.htm' target='right' class='orange' >任务可以分为普通任务和系统任务，系统任务有两个，一个为空闲任务，另一个为统计任务，</a><a href='../sentence_detail/284.htm' target='right' class='orange' >空闲任务是必须存在的，当系统没有其它任务可以运行时，空闲任务就会运行，</a><a href='../sentence_detail/285.htm' target='right' class='orange' >这样 CPU就不会没事可做了，统计任务用于统计 CPU的利用率。</a><a href='../sentence_detail/286.htm' target='right' class='orange' >普通任务即为开发者创建的任务。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">109</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/287.htm' target='right' class='red' >每个任务都有5种状态，分别是就绪态、运行态、等待态、休眠态、中断态。</a><a href='../sentence_detail/288.htm' target='right' class='orange' >当任务控制块设置完后，任务就进入就绪态了。</a><a href='../sentence_detail/289.htm' target='right' class='red' >当任务得到CPU而运行后，处于运行态。</a><span class='green'>当任务进入休眠后，就处于休眠态，当任务被挂起后就进入等待态，被中断的任务处于中断态。</span><span class='green'>各种状态的转换图如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">110</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-4 任务状态转换图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">111</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.2 任务的调度机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">112</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/294.htm' target='right' class='orange' >在嵌入式操作系统里，任务的调度是非常关键的，操作系统的实时性和多任务的能力主要取决于所采用的调度策略。</a><a href='../sentence_detail/295.htm' target='right' class='orange' >从操作系统的调度策略角度来看，可分为基于优先级的调度策略和基于时间片的轮转调度策略，</a><a href='../sentence_detail/296.htm' target='right' class='red' >从调度方式上来讲，可分为抢占式调度、非抢占式调度以及可选择抢占式调度等，</a><a href='../sentence_detail/297.htm' target='right' class='orange' >从时间片上来看，可分为固定与时间片可变的调度[8]。</a><a href='../sentence_detail/298.htm' target='right' class='orange' >在一般的嵌入式操作系统里，为了能使系统能够快速响应外部突发事件，一般都采用基于优先级的调度算法[6]。</a><a href='../sentence_detail/299.htm' target='right' class='orange' >至于抢占式调度和非抢占式调度，由于在抢占式调度中，只要最高优先级的任务一旦就绪，</a><a href='../sentence_detail/300.htm' target='right' class='orange' >就能得到 CPU的使用权，而非抢占式调度中，当前任务会一直占用 CPU，直到其运行完成。</a><a href='../sentence_detail/301.htm' target='right' class='orange' >因此，为了确保系统的实时性，本课题所设计的嵌入式操作系统是采用了按优先级的抢占式调度机制。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">113</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/302.htm' target='right' class='orange' >采用按优先级的抢占式调度策略，任何时刻都运行着最高优先级的就绪任务。</a><a href='../sentence_detail/303.htm' target='right' class='red' >当一个运行的任务使一个更高优先级的任务进入了就绪状态，当前运行任务的 CPU使用权就会被更高优先级就绪任务所抢占，</a><a href='../sentence_detail/304.htm' target='right' class='red' >如果是中断服务使一个更高优先级的任务进入就绪状态，那么当中断完成后，被中断的任务将会被挂起，</a><a href='../sentence_detail/305.htm' target='right' class='red' >优先级更高的任务就会开始运行。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">114</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/306.htm' target='right' class='red' >如下图所示，两个不同优先级任务和一个中断服务的执行情况，当低优先级任务被中断后，</a><a href='../sentence_detail/307.htm' target='right' class='red' >系统进入中断服务子程序 ISR，中断服务子程序 ISR同时使一个更高优先级的任务进入就绪状态，</a><a href='../sentence_detail/308.htm' target='right' class='orange' >当中断服务程序执行完后，调度器会选择更高优先级的就绪任务来运行，而不是恢复被中断了的任务继续运行[9][10]。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">115</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/309.htm' target='right' class='red' >图3-5 优先级抢占式调度</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">116</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/310.htm' target='right' class='orange' >基于优先级的调度策略，每个任务都拥有一个由设计者按照任务的重要性来编排的优先级号。</a><a href='../sentence_detail/311.htm' target='right' class='orange' >任务的优先级设计是十分重要的，可以分为支持同优先级和不同优先级两种。</a><a href='../sentence_detail/312.htm' target='right' class='orange' >支持同优先级任务即多个任务可以拥有相同的优先级，而不同优先级是每个任务必须分配各不相同的优先级。</a><a href='../sentence_detail/313.htm' target='right' class='orange' >采用支持同优先级的方式比较适合现实情况，每个任务的优先级高低并不是绝对的，每个任务的地位基本相同，</a><span class='green'>并有一定的周期性[8]，但采用这种方式，任务的调度和任务的控制块就会变得相对复杂，</span><span class='green'>对于初做系统，可以采用相对简单的方式，更好的改进方式可以留到下一阶段来继续完成。</span><span class='green'>因此，本设计采用不同优先级的方式，虽然这种设计方法比较简单，但也是有比较多的问题，</span><span class='green'>其中就有优先级反转的问题，本设计里没有设计出针对此问题的解决方案，但已经有许多参考资料提出来了解决的方法，</span><span class='green'>这一部分也是留到下一阶段继续改进的地方。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">117</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/319.htm' target='right' class='orange' >采用不同优先级的方式，每个任务都拥有一个不同的优先级，因此，可以把任务的ID号等同于优先级号。</a><a href='../sentence_detail/320.htm' target='right' class='orange' >这里优先级号采用整数来表示，0为最高优先级，数字越大，优先级越低。</a><a href='../sentence_detail/321.htm' target='right' class='red' >优先级高的任务先运行，优先级底的任务后运行。</a><a href='../sentence_detail/322.htm' target='right' class='orange' >当系统进行调度时，可以在任务控制块链表中查找最高优先级就绪的任务来运行，</a><span class='green'>由于创建任务时，并不一定是按照任务的优先级来分别创建的，因此，如果在任务控制块链表中来查询，</span><a href='../sentence_detail/324.htm' target='right' class='orange' >其效率比较低，对系统的实时性造成影响。</a><span class='green'>所以，这里可以采用一个有序表，即一个一维数组，数组0表示0号任务，数组1表示1号任务，</span><a href='../sentence_detail/326.htm' target='right' class='orange' >以此类推，每个数组指向对应的任务控制块地址，即数组0是执行0号任务的任务控制块。</a><span class='green'>当进行查询时，就可以从数组0开始往下查找，如果数组N为空，表明不存在N号任务；</span><a href='../sentence_detail/328.htm' target='right' class='orange' >如果数组N存在，那么数组N所指向的任务控制块就是最高优先级就绪任务了。</a><span class='green'>模型图如下所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">118</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-6 优先级有序表</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">119</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/331.htm' target='right' class='orange' >这里采用顺序查找的算法虽然比较简单，但并不是最好的。</a><a href='../sentence_detail/332.htm' target='right' class='orange' >我们可以在创建任务时，根据任务的优先级顺序插入到任务控制块链表中相应的位置，</a><a href='../sentence_detail/333.htm' target='right' class='orange' >这样每次查找时就能更加快捷，但创建任务所花费的时间也会相对增加，</a><span class='green'>特别是当任务比较多的时候，这些改进也可留到下阶段改进。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">120</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.3 任务的创建</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">121</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/336.htm' target='right' class='orange' >每个任务都由任务控制块链表中的任务块进行管理，当系统运行后，会把每个空的任务控制块连接成一个链表，</a><a href='../sentence_detail/337.htm' target='right' class='orange' >称为空任务块控制链表，当需要创建任务时，便可从这个链表中拿出一个空的任务控制块，</a><span class='green'>来设置任务的相关信息。</span><a href='../sentence_detail/339.htm' target='right' class='orange' >所有创建好的任务控制块会连接到另外一个任务控制块链表中，当系统进行调度时，便会从这一链表中选出任务块来运行任务。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">122</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务的创建最关键就是设置任务的栈，本系统中每个任务都拥有一个固定的栈，栈空间的大小由开发者定义，毕竟不同开发板其内存资源也是不同的。</span><span class='green'>栈空间主要用于切换任务时，保存当前任务在CPU上寄存器的数据，以便将来恢复当前任务继续运行。</span><span class='green'>当任务首次创建时，PC寄存器会指向当前任务的函数入口地址，当函数被调度运行时，便可跳到对应的函数，开始执行程序。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">123</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>当设置好任务的栈后，还需要把任务块连接到任务控制块链表中，这样任务的状态就可以设置为就绪，等待系统调度运行了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">124</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/344.htm' target='right' class='orange' >任务链表和任务块的基本模型如下所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">125</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-7 任务链表图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">126</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.4 任务的挂起和恢复</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">127</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>每个普通任务都可以挂起任务自身或者其它任务，当任务被挂起时，就会处于挂起态，这时，不论任务的优先级是什么，都不会得到系统的调度运行。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">128</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>被挂起的任务只能通过其它任务来恢复，只要把被挂起任务的状态清掉，那么该任务就可继续参与到系统的调度中。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">129</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.6.5 任务删除</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">130</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>任务删除操作可以删除其它任务或者删除任务自身，为了让被删除的任务能够释放自身所占用的资源，</span><span class='green'>我们可以先发送一个删除任务的消息给对方，当对方收到这个消息后，就可以进行适当的步骤后再删除自身，</span><span class='green'>这种方法要比直接删除任务更安全、灵活。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">131</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.7 中断服务模块的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">132</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>中断服务模块主要为操作系统提供中断响应机制，当系统接收到外部中断请求后，会停止当前正在运行的任务，从而转到中断服务子程序进行中断处理。</span><span class='green'>本系统暂时只需要外部中断请求IRQ，因此只讲解外部中断的请求过程，对于其它中断比如快速中断FIQ等可以参考S3C6410芯片手册进行编写。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">133</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>每个任务需要打开中断后才能响应中断，在任务堆栈的初始化时，应当把每个任务的状态寄存器即 CPSR设为0 x0000001 F，</span><a href='../sentence_detail/357.htm' target='right' class='orange' >即处于系统工作模式并打开 IRQ中断。</a><a href='../sentence_detail/358.htm' target='right' class='red' >这样当有中断时，系统就会跳转到中断处理函数。</a><a href='../sentence_detail/359.htm' target='right' class='orange' >本系统的主要中断处理函数有时钟定时器中断处理和按键中断处理。</a>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_10.htm">尾页</a>
页码：4/10页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
