<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=7"/>
<title>【维普论文检测系统-个人版】比对报告</title>
<link href="css/report_detail.css" type="text/css" rel="stylesheet" />
<style type="text/css">
body{background:#222}
</style>
<script type="text/javascript" src="script/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="script/reportshow.js"></script>
</head>
<body>
<div class="topbar">
	<img src="images/logo_black.gif" alt="维普论文检测" />
</div>
<div class="layout_body">
	<div class="layout_right">
		<div class="content yahei">
			<div class="cqvip-jianceorgan-paperreportpartpanel"></div>
			<div class="sidebars">
				<ul class="song">
				<li class="bold">文档中颜色标注说明：</li>
				<li><img src="images/color_red.gif"/> 红色字体代表相似片段； </li>
				<li><img src="images/color_yellow.gif"/> 黄色字体代表引用片段； </li>
				<li><img src="images/color_black.gif"/> 黑色字体代表自写片段； </li>
				<li><img src="images/color_green.gif"/> 绿色表示参考文献引用规范。 </li>
				<li>请注意黄色字体的引用标注和参考文献序号是否相同。 </li>
				<li>总相似比为红色字体和黄色字体占文章的总比率。</li>
				</ul>
			</div>
			<div class="sidebars song">
			<b class="block">免责声明：</b>
			1. 报告编号系送检论文检测报告在本系统中的唯一编号。<br/>
			2. 本报告为维普论文检测系统算法自动生成，仅对您所选择比对资源范围内检测结果负责，仅供参考。
			</div>
		</div>
	</div>
	<div class="layout_left">		<div class="artical f16 yahei">			<span style="position:absolute;top:0;left:0;display:block;padding:5px 20px;background:#fff3ed;border-right:1px solid #f8d8d8;border-bottom:1px solid #f8d8d8;"><img src="images/icon_search.gif"/>&nbsp;检测结果：总相似比：<b class="tahoma red f16">16.32%</b>&nbsp;&nbsp;相似片段数：<b class="tahoma f16">80</b>&nbsp;&nbsp;&nbsp;&nbsp;<i class="f14"><img src="images/icon_ding.gif"/>&nbsp;点击红色文字查看相似片段详情</i></span>			<div class="tit">				<h1 class="f22 block a_center">嵌入式系统设计_检测_2</h1>				<span class="block a_center f14">论文作者：何伟强&nbsp;&nbsp;&nbsp;&nbsp;检测时间：2014-05-30 10:02:21.0</span>			</div>			<div class="detail">			    <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绪论<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1 课题来源及研究目的与意义<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嵌入式开发是当下热门的开发，嵌入式技术普遍的应用于各个领域。学习嵌入式开发，大多选择51单片机或者ARM芯片来进行学习开发，由于ARM芯片是大多数嵌入式设备的主要开发平台，而且ARM芯片具有性能高、体积小、功耗低等特点，因此学习ARM嵌入式开发具有一定的优势。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习嵌入式开发，可大概分为：嵌入式应用开发、嵌入式操作系统系统开发和硬件开发。嵌入式应用和嵌入式系统操作系统开发一般都紧密结合，而当下嵌入式操作系统虽多，但即使是像μC/OS或者QNX这些小巧的嵌入式操作系统内核，其代码量也是非常多的，而像嵌入式Linux的，其代码就更加庞大了。对学习操作系统的学生来说，由于缺少对操作系统设计和实现的经验，在没有一个比较清晰的思路和逻辑的情况下，去阅读内核代码是非常徒劳无用的。因此，我们需要自己动手，实际去编写一个嵌入式操作系统，哪怕这个操作系统只能进行简单的任务调度，这也能加深我们对操作系统原理的理解，激发我们的热情和兴趣，继续去为这个内核添加更多的功能。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择设计嵌入式操作系统这个题目，具有重大而深远的意义。计算机系统里面最重要的部分就是操作系统了，<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="1">在学习和设计操作系统的过程中，能加深我们对操作系统基本原理的理解，对计算机系统的工作过程也会更加清晰</a>。虽然嵌入式操作系统和通用的计算机系统具有一定的差别，但其基本的工作原理都是相同的，而嵌入式操作系统相对于通用计算机系统，其内核更加小巧，更加适合学习和开发。因此本论文所写的小型嵌入式操作系统，其内核功能也是相对简单，但主要还是以加强对操作系统的理解，并运用基本的原理来设计开发一个能正常运行和工作的操作系统。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2 嵌入式操作系统的现状与分析<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="2">嵌入式系统是从20世纪70年代微处理器出现后发展起来的，当时的系统结构和功能相对单一，主要用于工业控制[1]</a>。如今，通信、工业控制、消费电子、航空、航天等都存在着嵌入式设备的身影，嵌入式已经普遍的应用于各个领域中。近年来，嵌入式技术的发展越来越突飞猛进，移动设备、平板电脑等已成为人们生活中不可或缺的电子产品，现在物联网、智能家居、可穿戴式设备等嵌入式技术也正大力发展中。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="3">嵌入式操作系统（Embedded Operating System，EOS）是嵌入式系统的核心部分，与通用计算机操作系统相比，具有专用性、可裁剪、易移植、高可靠等特点</a>。如今，已经拥有相当多的主流嵌入式操作系统，比如VxWorks、Windows CE、FreeRTOS、μC/OS-Ⅱ/Ⅲ、嵌入式Linux、eCOS、QNX等等，还有应用于移动设备上的操作系统也属于嵌入式操作系统，像Android、iOS、Windows Phone、Firefox OS等等。这些嵌入式操作系统既有商业付费的，也有开源免费的，都是当前普遍应用于各种设备上的嵌入式操作系统。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然低端的嵌入式设备不一定具备嵌入式操作系统，但大多数嵌入式设备都由嵌入式操作系统来管理其相应的软件和硬件资源。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="4">不同的嵌入式操作系统包含不同的基本功能组件，但都具备一个基本的内核，这个内核主要的功能就是提供多</a>任务的管理、时间的管理、事件的管理、内存的管理和设备的管理等，实现既有简单也有复杂，像μC/OS<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="5">-Ⅱ的内核就相对简单，而嵌入式Linux就和桌面版的Linux差不多了，因此功能也相对更强大</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前，大多数嵌入式操作系统的技术大都以国外为主，国内嵌入式的发展技术与美国等发达国家相比还存在着一定的差距，但总体的发展趋势还是相当好的，像智能家居、可穿戴式设备等国内也搞得很火热。而自主的嵌入式操作系统并没有得到广泛的应用，因此，我国不论是嵌入式系统还是相关的嵌入式技术发展，还是具有比较大的发展空间，国内的嵌入式开发前景还是非常不错的。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3 本论文的主要工作<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本论文所设计的小型嵌入式操作系统完成的主要工作和解决的难点有以下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查阅国内国外有关嵌入式的文献资料，比如嵌入式发展的历史与现状、应用领域、嵌入式系统的基本设计和实现等。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习ARM的体系结构和基本汇编，掌握S3C6410的硬件结构和ARM嵌入式的开发，并编写开发板上相应的引导程序和硬件驱动。其中的主要难点是向开发板的NAND Flash写入操作系统的引导程序，中断服务程序的编写，系统更新程序的编写等。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用所学操作系统的基本原理，在开发板上实现一个简单的操作系统，该系统采用了按优先级抢占式的调度机制来进行任务调度，并拥有简单的内存管理功能。其中设计难点有任务控制块的设计，任务的切换、调度、中断的实现等。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本系统还实现了基本的时间管理功能，如让任务进行延时等操作，同时还有任务的挂起、恢复、删除等操作。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本嵌入式操作系统的基础上设计测试应用来验证该系统的功能，并在最后对该系统提出一些能继续进行改进的地方。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARM技术及开发板介绍<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1 ARM体系结构<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1 ARM处理器的简介<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="6">嵌入式系统的核心硬件就是嵌入式处理器，嵌入式处理器的体系结构如果按不同的内核系列可以分为51、A</a>VR、MIPS、PowerPC、ARM等，像51单片机采用的就是51系列的内核芯片，Arduino采用的就是AVR的芯片，而ARM就是目前最广泛使用的嵌入式处理器芯片。从1991年到2014年，ARM处理器的历史出货量已经超过了500亿颗，广泛的应用于移动领域、嵌入式领域、企业和家用等市场[2]。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="7">ARM既是一间公司的名字，也是一系列处理器的名称。ARM的全称是Advanced RISC Ma</a>chine，由此可看出ARM处理器的指令集是精简指令集（Reduced Instruction Set Computer，RISC）。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="8">ARM处理器的主要特点是功耗低、省电、性能强大、成本低，拥有16位Thumb、32位ARM和Th</a>umb-2双指令集，最重要的是ARM拥有许多领域方面的合作伙伴，像苹果、三星、高通等，因此使得ARM处理器能全面广泛的应用于多个领域。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARM处理器多数为哈佛结构，拥有16/32位指令集，多处理器状态模式等设计技术。ARM处理器不同<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="9">的内核采用不同的体系结构，像经典处理器的ARM7采用的是ARMV4T的结构，Cortex-A采用的是ARMV7-A的结构，具体可到ARM公司的官网查看ARM内核采用的体系结构版本</a>。目前市场上主要使用的内核有ARM7、ARM9的老架构，还有近年来比较流行的Cortex-A和Cortex-M系列的架构芯片。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2 ARM处理器的工作状态和工作模式<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="10">ARM处理器一般拥有2种工作状态和7种工作模式，因为ARM处理器拥有16/32位指令集，因此ARM处理器可以在ARM和Thumb及Thumb-2这两种工作状态间切换</a>。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="11">ARM状态就是ARM处理器完全工作在32位指令下的状态，在此状态下的指令长度均为32位。Thum</a>b状态就是工作在16位指令下的状态，这时的指令代码只有16位，占用的内存空间小，代码密度大，能提供比32位程序代码更好的性能。Thumb-2状态是ARM处理器新的状态，首次出现在ARM11系列的芯片。Thumb-2同时具有16位和32位的指令，能提供更高性能、功耗更小和占用内存更小的优点。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="12">ARM处理器复位后只处于ARM状态，可通过相应的指令集在ARM状态和Thumb状态下进行切换</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="13">ARM有7种工作模式，分别是用户 模式、快速 中断 模式、外部 中断 模式、管理 模式、中止 模式、未定义 指令 模式和系统 模式</a>。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="14">当工作模式为用户模式时，处理器将不能改变当前的工作模式，除非发生异常，其它的工作模式能进行互相切换</a>。通过相应的指令可以向程序状态寄存器CPSR的第0到第4位，即[M4:M0]写入相应的值即可进入对应的工作模式。具体的工作模式如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="15">图2-1 ARM处理器的工作模式</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.3 ARM处理器的寄存器<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="16">ARM处理器有31个通用寄存器，6个状态寄存器，总共是37个32位的寄存器，ARM状态下不同工作模式的寄存器如下图所示</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2-2 ARM状态下的寄存器<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="17">从图2-2可看出，ARM处理器在不同的工作模式下所使用的寄存器是不同的。通用寄存器R0-R7在所</a><a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="18">有模式下是共用的，快速中断模式下有自己专用的寄存器R8-R12，系统模式和用户模式下使用相同的堆</a>栈指针R13（Stack Pointer，SP）和程序链接寄存器R14（Link Register，LR），其它模式都有自己特定的寄存器。最后一个通用寄存器是程序计数器R15，总共有31个通用寄存器。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="19">状态 寄存器有1个当前 程序 状态 寄存器 CPSR，5个 备份 程序 状态 寄存器 SPSR，</a><a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="20">分别用于5种工作模式，用户模式和系统模式没有备份程序状态寄存器，程 序状 态寄 存器的格式如下图所示</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2-3 程 序状 态寄 存器 格式<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M4-M0为模式选择位，决定处理器工作于哪种模式。T位为ARM与Thumb指令切换，T为1时执行Thumb指令，为0时执行ARM指令。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="21">F位为快速中断控制位，F为1时禁止FIQ中断，为0时允许快速中断。I位为中断控制位，I为1时允许外部IRQ中断，为0时禁止IRQ中断</a>。第27位到31位为条件码标志，详细可参考ARM手册。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于本论文所写的嵌入式操作系统是工作在ARM状态下的，因此只简单介绍ARM状态下的寄存器情况，对于Thumb及Thumb-2状态下的寄存器情况并没有做相关的介绍。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="22">2.1.4 ARM处理器的异常处理</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="23">ARM处理器拥有7种不同类型的异常，分别是复位、未定义 指令、软件 中断、指令 预取 中止、数据</a> 访问 中止、外部 中断 请求、快速 中断 请求，它们的优先级及对应的异常向量地址如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2-4 ARM异常类型、优先级及向量地址<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="25">7种异常可分为6级，其中复位优先级最高，未定义指令和软件中断最低，而且这两个异常是互斥的，不可能同时发生，所以它们的优先级是相同的</a>。当复位的引脚有效时，系统便无条件的进入管理模式，并把PC指向0x00000000处开始执行指令。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="26">当ARM处理器发生异常后，如果是复位异常，会立即中止当前运行的指令，如果是其它的异常，处理器会执行完当前指令后，再去处理异常</a>。ARM处理器异常的响应过程如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将当前工作模式下状态寄存器的值保存到对应异常模式下的备份状态寄存器中，以便保护当前任务的状态信息。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="27">设置当前状态寄存器为相应的异常工作模式，而且禁止IRQ外部中断，如果进入的是复位模式或快速中断模式，还要禁止FIQ快速中断</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="28">把异常指令的下一条地址保存到异常模式下的寄存器R14中，当异常处理完后，程序才能返回原来的指令处继续向下执行</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给程序计数器PC强行赋值，跳到对应的异常向量地址处执行相应的处理函数。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每种异常模式下都有自己对应的SP和LR两个寄存器，分别用来存放堆栈指针和断点地址。以上的4步工作都是由ARM处理器的硬件自动完成的，我们只能做的是设计异常处理程序，并从异常处理程序中返回到原来的程序处。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于ARM处理器采用了多级流水线的技术，因此在实际编程时，第3步将引起异常指令的下一条地址保存到异常工作模式下的R14中，该地址往往不是正确的返回地址。因此我们通常在进入异常处理程序后，修改LR的值，以保证返回时是正确的地址。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARM处理器从异常程序返回到原来的程序处继续向下执行的过程如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将异常模式下的备份状态寄存器的值复制到原理的状态寄存器中，还原到被中断前的工作状态。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将LR的值装入到程序计数器PC中，使得程序能返回原来的程序处，这里LR的值为返回地址值。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="29">清除CPSR中的中断屏蔽位，打开IRQ外部中断和FIQ快速中断</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的异常中断的返回顺序不能混乱，只能是先恢复CPSR的值，再从LR中恢复断点地址，返回原来的程序。如果顺序搞乱了，系统就会发生错误。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2 Ok6410开发板的介绍<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="30">本论文所写的嵌入式操作系统是在飞凌公司的OK6410开发板下所完成的，OK6410开发板是基于三星公司的ARM11处理器S3C6410</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 S3C6410芯片简介<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由S3C6410芯片手册[3][4]可知，S3C6410是一个16/32位的RISC处理器，用来提供一种有经济效益的、低功耗的、高性能，能适用于移动电话和一般应用的处理器解决方案。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="31">S3C6410采用64/32位的内部总线架构，为2.5G和3G通信服务提供了优化的H/W性能，该64/32位的内部总线架构是由AXI、AHB和APB总线组成的</a>。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="32">它还有很多强大的硬件加速器，比如2D图像处理、图形显示和缩放处理、运动视频处理、音频处理等</a>。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="33">一个集成的多格式编解码器（Multi Format Codec，MFC）和MPEG4/H.263/H.264编解码器和VC1解码器</a>。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="34">这种H/W编解码器能支持实时视频会议和电视输出的NTSC和PAL两种模式。此外，该处理器含有一个3D加速器，支持OpenGL ES 1.1/2.0的图形渲染</a>。这种3D引擎还有两个可编程着色器：一个像素着色器和一个顶点着色器。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="35">S3C6410具有一个优化的接口连接到外部存储器。这种优化的接口，外部存储器是能在高速通信服务上维持高内存带宽</a>。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="36">内存系统具有双重外部存储器端口，DRAM和Flash/ROM。在DRAM端口可以配置为支持mobile DDR、DDR、mobile SDRAM和SDRAM内存</a>。在Flash/ROM端口可以支持NOR Flash、NAND Flash、OneNand、CF和ROM等类型的外部存储器。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="37">为了降低系统的总体成本和提高整体功能，S3C6410包含了许多硬件外设，例如相机接口、TFT 2</a><a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="38">4位真彩色LCD控制器、系统管理器（电源管理等）、4个的UART、32个DMA、5个32位定时器</a>（其中有2个是PWM输出）、通用I/O接口（GPIO），I2S总线接口、I2C总线接口、USB主<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="39">设备、USB OTG设备高速传输（480Mbps）、3通道SD/MMC主机控制器和PLL时钟发生器</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="40">S3C6410的ARM子系统是基于ARM1176JZF-S内核。它包括独立的16KB指令和16KB的数据缓存、16KB指令和16KB的数据TCM</a>。它还包括一个完整的MMU来处理虚拟内存管理。ARM1176JZF-S是一款单芯片的微控制器，其中包括JAVA加速器。ARM1176JZF-S包括一个专用的矢量浮点协处理器，允许高效的实现各种加密方案和3D图形应用程序。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="41">S3C6410采用实际标准的AMBA总线架构。这种强大的、行业标准的特点让S3C6410能够支持许多工业标准的操作系统</a>。下图2-5就是S3C6410的芯片架构图。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2-5 S3C6410芯片架构<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 Ok6410开发板简介<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="42">OK6410开发板采用S3C6410芯片，拥有强大的内部资源和视频处理能力，可以稳定运行在667MHz主频上，支持Mobile DDR和多种NAND Flash</a>。<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="43">OK6410开发板上集成了多种高端接口，如液晶屏、以太网、复合视频信号、摄像头、SD卡、USB等，并配备红外接收头、温度传感器等[5]</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该开发板拥有256MB Mobile DDR内存和MLC 4GB NAND Flash外存，主频<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="44">为533MHz/667MHz，总共有4个串口，包括1个五线RS-232电平串口（DB9母座）和3</a>个三线TTL电平串口，1个RTC实时时钟，4个LED，6个按键，1个蜂鸣器，还有其它的硬件资源，详细可参考开发板硬件手册[5]。下图2-6就是OK6410开发板的实物图。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2-6 OK6410开发板<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3 本章小结<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章主要简单介绍了ARM的体系结构，比如ARM的工作状态、工作模式、寄存器和异常处理。然后简单介绍了所使用的OK6410的开发板的简单情况，包括S3C6410的芯片，最后详细介绍了如何在Linux下搭建基本的交叉开发环境。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统分析与设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1 系统的设计目标<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本论文所设计的小型嵌入式操作系统，是在ARM开发板上实现的，该系统具备基本的多任务调度，也就是说应用开发者能创建多个任务来进行工作，每个任务间通过本系统的调度算法来进行分配任务的运行，同时本系统具有简单的内存管理功能，开发者可以在任务运行时，根据需要进行申请内存和释放内存。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="45">经分析，本嵌入式操作系统需要实现以下的基本功能：</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务的基本操作功能。这里包括任务的创建、任务的挂起和恢复、任务的删除等，这里的难点主要是多任务调度的设计。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断服务功能。中断服务的功能模块是本操作系统的核心，也是难点之一。中断服务涉及开发板相关的底层操作，大部分采用ARM汇编来编写中断服务的进入和退出。中断服务子程序（Interrupt Service Routines，ISR）一般都是采用简单的C语言来编写，主要完成在中断时进行的操作，比如系统的时钟服务。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间管理功能。这里的时间管理功能主要用于系统的时间节拍，可以用来对任务进行延时，也可用来获取系统运行的总节拍数。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存管理功能。这里是比较简单的内存管理，主要采用固定分区法，在预先分配好的二维数组里进行内存分配。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2 系统的总体结构<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统的总体架构包括：系统的引导和启动、硬件的初始化、系统的运行等。本论文主要把整个系统分成4个模块：引导启动模块、系统更新模块、串口通信模块、操作系统模块。其中操作系统模块根据系统的基本功能又细分为任务管理模块、时间管理模块、中断服务模块和内存管理模块。总体的结构模块如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引导启动模块。这个模块的主要功能是引导开发板的启动，主要是以ARM汇编为主。主要包括设置ARM异常向量的地址、设置外设接口的地址、关闭看门狗、设置CPU的主频、初始化SDRAM和NAND Flash、把代码复制到SDRAM中等。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统更新模块。由于操作系统不可能一次编写，就能成功运行所有功能，因此需要不停的往开发板重复烧写新的操作系统程序。由于每次烧写目标程序时都需要使用u-boot在Windows下才能把程序写进NAND Flash上，比较麻烦，而且在Linux下没有相关的Linux驱动，因此，本课题里设计了一段能自行更新NAND Flash上目标程序的代码，并集合到系统上。这个系统更新模块主要采用串口通信来获取新的目标程序，系统引导启动后就能直接选择更新系统或者运行系统，即方便又简单。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;串口通信模块。这里的串口通信模块主要方便调试，开发板通过串口与主机进行通信，可以让开发板输出相关的信息，然后在主机上显示，而且这个串口通信模块还包括主机上的串口通信软件。这个通信软件是本课题里自行编写的软件，其中串口通信方面采用了第三方写的插件，而且这个软件结合系统更新模块，主要是通过串口来传输二进制文件来更新开发板上的系统程序代码。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作系统模块。本模块可以分为任务 管理 模块、中断 服务 模块、时间 管理 模块和内存 管理 模块。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-1 嵌入式操作系统的总体模块图<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3 引导启动模块的设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="46">引导启动模块是整个嵌入式系统的首要模块，主要功能就是引导并启动操作系统，跟bootloader类似</a>。整个引导启动模块所做的工作首先就是初始化相关的硬件，然后跳到系统的启动界面。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引导启动模块往往与芯片和开发板紧密结合，因此不同的开发板其实现过程往往不同，但其思路基本是一样的，下面基于OK6410开发板，介绍其引导模块的设计过程。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置 异常 处理 函数 的入口地址。根据ARM的体系结构可知，地址0x0000000到0x0000001F是ARM异常向量的入口地址，当ARM芯片启动或复位后，系统会自动从0x00000000<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="47">的地址处开始执行程序，因此我们需要在0x00000000处设置一条跳转指令，跳转到程序的初始化处</a>，其余的异常向量入口地址需要填写相应的异常处理函数的入口地址，以便异常发生时，系统跳转到相应的处理函数处。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化相关的硬件。当系统进入初始化处程序后，就进行相关的硬件的初始化了。这里首先要禁止所有的IRQ和FIQ中断，然后根据S3C6410的芯片手册[4]，还需设置外设寄存器的地址后才能设置相关寄存器的值。接着是关闭看门狗，大多数嵌入式芯片都有看门狗的功能，因此需要关闭看门狗，不然系统会每隔一段时间就会自动重启。然后初始化其它的硬件，比如CPU的频率，SDRAM和NAND Flash，这些寄存器的设置只需根据相关的芯片手册来进行初始化即可。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）系统硬件初始化完后，还需要进行重定位代码。由于S3C6410芯片启动后会自动从NAND Flash中复制8KB的数据到芯片的SRAM中运行，但往往一个操作系统的大小会超过8KB，因此，我们需要把程序复制到内存SDRAM上，然后从SRAM跳到SDRAM中继续运行，这一步骤就是重定位。重定位只需将NAND Flash中的代码段TEXT和数据段DATA复制到SDRAM中，最后清零BSS段即可。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位后，就准备跳到SDRAM中继续执行代码了。这里一般是跳到main函数开始执行主程序，但在本系统中，由于存在系统更新模块，因此是首先跳入到更新函数，然后再执行main函数。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后是异常处理程序的编写。由于发生异常后，系统会跳到异常向量地址处，执行异常向量地址处的函数。在进入异常处理程序前，首先需要保存当前任务数据，即将CPU相应的寄存器数据入栈。由于ARM存在流水线的问题，因此寄存器LR的返回地址不一定是正确的返回地址，需要根据哪种异常来进行修改。然后进入异常处理程序，当异常处理完毕后，还原被中断任务数据。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARM有7种异常，由于复位异常不需编写异常处理程序，所以实际只需编写6个异常处理的函数。但因为本系统中只用到外部中断IRQ，所以只编写了IRQ的处理函数，其余5个异常处理程序，开发者可根据实际需要进行编写。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4 串口通信模块的设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;串口通信模块对于嵌入式系统的调试是非常重要的，本模块可分为主机和开发板两部分，开发板和主机通过串口可以互相发送和接收数据。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝大多数的开发板都有一个串口插座，OK6410开发板有一个DB9的串口母座，可直接与计算机的串口进行连接通信。要进行串口的通信，首先需要设置开发板的串口，比如串口波特率，数据位，停止位，校验位等，可根据芯片手册来设置相应的寄存器。要通过开发板的串口发送数据，只需将该数据逐位写到相应的寄存器便可发送到PC的串口上，接收数据也是类似，从相应的寄存器去读取数据。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发板上实现基本的串口通信比较简单，而在主机上，比如Windows系统，往往有较多的串口通信软件，但由于本系统存在系统更新模块，而系统的更新，是通过串口来获取新的程序代码来实现的，因此，本系统还实现了一个能够发送二进制文件的串口通信软件。该软件基于Qt来开发，串口通信的实现主要通过第三方的插件来实现，除了基本的串口通信外，还能配合系统的更新模块来发送更新系统的程序，简单方便。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5 系统更新模块的设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当程序进入系统更新模块后，就可以选择更新系统程序或者运行系统。系统更新模块主要用到串口通信，利用串口通信来接收主机的系统更新代码，把代码复制到NAND Flash上，然后重启系统，就能运行新的系统程序了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统更新模块的难点主要在于接收新的代码和把代码写入到NAND Flash上。本系统从内存地址0x5FC00000（离内存尾端4MB）处开始存放系统的更新代码，当接收完代码数据后，然后在将数据写入到NAND Flash上。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="48">不同的NAND Flash其读写的数据方式也不同，因此需要根据NAND Flash的芯片手册来进行编写</a>。这里还要注意S3C6410上的NAND Flash陷阱，OK6410开发板的NAND FLash是以页来读取数据的，每页有4KB是用来存储数据，218个字节来存放校验和等信息。按照原理，S3C6410处理器是从前两页读取8KB的数据到SRAM中，但其实并不是这样的。S3C6410会从前4页，每页读取2KB，总共8KB的数据到SRAM中，所以，当把系统代码更新时，并不能直接把数据从NAND Flash的第一页开始写下去，而是需要把8KB数据写到4页里，第2到第5页的前2KB数据与前一页的后2KB数据相同，如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-2 NAND Flash前4页的数据写法<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，关于开发板从启动到准备运行操作系统，本设计把这一阶段分为了三个模块来讲解，其中串口通信模块和系统更新模块并不是必须的，但对于系统的调试和更新是非常方便的，如果到了应用正式部署的时候，可以选择性的删除。这三个模块与开发板的硬件紧密结合，不同的开发板其实现过程也是不同的，因此这里只是简单的介绍了在OK6410下的设计过程，其它的需要根据实际的开发板进行相应的移植和修改。当系统的环境准备好后，就可以开始载入操作系统并开始运行了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6 任务管理模块的设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6.1 任务的定义及其结构<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当人们在生活中遇到一个大而困难的问题时，往往会把这个大问题分解成多个简单和容易解决的小问题。在实际编程中，当面对大的应用程序时，我们也会把它编写成一个个小程序来完成目的，这种方法即能提高CPU的利用率，同时又缩短程序的执行时间。由于嵌入式系统都是与具体的应用紧密结合的，都是针对解决某一类问题，因此可以把这一类问题分解成许多小问题，再交给操作系统来进行处理。利用这种思路，在嵌入式操作系统里，就可以把每个大问题转化为多个任务，每个任务都有自己相应的工作函数，由操作系统来进行任务的调度和管理，这样就能实现一个多任务的操作系统了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个任务可以看做是一个线程，都是一段简单的程序，典型的任务都是一个无限循环的函数，由任务控制块来进行管理，一般都包括任务的栈地址，任务的优先级，任务的函数地址等信息[7]。<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="49">每个任务都属于整个应用的某一部分，都被赋予一定的优先级，有自己独立的栈空间，彼此独立运行[6]</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本论文设计的嵌入式操作系统由任务控制块链表来管理各个任务，任务的基本模型如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-3 任务链表<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务可以分为普通任务和系统任务，系统任务为空闲任务和统计任务，空闲任务是必须存在的，当系统没有其<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="50">它任务可以运行时，空闲任务就会运行，这样CPU就不会没事可做了，统计任务用于统计CPU的利用率</a>。普通任务即为开发者创建的任务。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个任务都有5种状态，分别是就 绪 态、运 行 态、等 待 态、休 眠 态、中 断 态。当任务控<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="51">制块创建完后，任务就进入就绪态了，当任务得到CPU而运行后，处于运行态，当任务进入休眠后，就处于休眠态，当任务被挂起后就进入等待态，被中断的任务处于中断态</a>。各种状态的转换图如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-4 任务状态转换图<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6.2 任务的调度机制<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在嵌入式操作系统里，采用哪种调度策略，对操作系统的表现是有很大影响的，如果调度机制不完善，会影响系统的实时性。<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="52">嵌入式操作系统的调度算法可分为优先级法和时间片轮转法，优先级法又可分为非抢占式优先级法和抢占式优先级法，时间片轮转法也可分为时间固定与可变两种方式[8]</a>。<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="53">对于大多数的嵌入式实时操作系统，为了使系统能够快速响应外部突发事件，一般都采用基于优先级的算法[6]</a>。至于抢占式调度和非抢占式调度，由于在抢占式调度中，只要最高优先级的任务一旦就绪，就能得到CPU的使用权，而非抢占式调度中，当前任务会一直占用CPU，直到其运行完成才会让出CPU。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="54">因此，为了确保系统的实时性，本课题所设计的嵌入式操作系统采用了按优先级的抢占式调度机制</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="55">采用按优先级的抢占式调度策略，系统总能优先运行最高优先级的就绪任务。当一个任务在运行期间，使得另</a><a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="56">外一个更高优先级的任务进入了就绪状态，那么当前正在运行的任务的CPU使用权就会被更高优先级的就绪</a><a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="57">任务所占用，如果是中断服务使一个更高优先级的任务进入了就绪状态，那么当中断完成后，并不会继续运行被中断的任务，而是去运行更高优先级的就绪任务</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图所示，两个不同优先级任务和一个中断服务的执行情况，当低优先级任务被中断后，系统进入中断服务<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="58">子程序ISR，中断服务子程序ISR同时使一个更高优先级的任务进入就绪状态，当中断服务程序执行完后，调度器会选择更高优先级的就绪任务来运行，而不是恢复被中断了的任务继续运行[9][10]</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-5 优先级抢占式调度<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于优先级的调度策略，每个任务都拥有一个由设计者按照任务的重要性来编排的优先级号。任务的优先级设计是十分重要的，可以分为支持同优先级和不同优先级两种。支持同优先级任务即多个任务可以拥有相同的优先级，而不同优先级是每个任务必须分配各不相同的优先级。采用支持同优先级的方式比较适合现实情况，每个任务的优先级高低并不是绝对的，每个任务的地位基本相同，并有一定的周期性[8]，但采用这种方式，任务的调度和任务的控制块就会变得相对复杂，对于初做系统，可以采用相对简单的方式，更好的改进方式可以留到下一阶段来继续完成。因此，本设计采用不同优先级的方式，虽然这种设计方法比较简单，但也是有比较多的问题，其中就有优先级反转的问题，本设计里没有设计出针对此问题的解决方案，但已经有许多参考资料提出来了解决的方法，这一部分也是留到下一阶段继续改进的地方。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用不同优先级的方式，每个任务都拥有一个不同的优先级，因此，可以把任务的ID号等同于优先级号。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="59">这里优先级号采用整数来表示，0为最高优先级，数字越小，优先级越高，高优先级的任务先运行，低优先级的任务后运行</a>。当系统进行调度时，可以在任务控制块链表中查找最高优先级就绪的任务来运行，由于创建任务时，并不一定是按照任务的优先级来分别创建的，因此，如果在任务控制块链表中来查询，其效率比较低，对系统的实时性有一定的影响。所以，这里可以采用一个有序表，即一个一维数组，数组0表示0号任务，数组1表示1号任务，以此类推，每个数组指向对应的任务控制块地址，即数组0是执行0号任务的任务控制块。当进行查询时，就可以从数组0开始往下查找，如果数组N为空，表明不存在N号任务；如果数组N存在，那么数组N所指向的任务控制块就是最高优先级就绪任务了。模型图如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-6 优先级有序表<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里采用顺序查找的算法虽然比较简单，但并不是最好的。我们可以在创建任务时，根据任务的优先级顺序插入到任务控制块链表中相应的位置，这样每次查找时就能更加快捷，但创建任务所花费的时间也会相对增加，特别是当任务比较多的时候，这些改进也可留到下阶段改进。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6.3 任务的创建<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个任务都由任务控制块链表中的任务块进行管理，当系统运行后，会把每个空的任务控制块连接成一个链表<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="60">，称为空任务块控制链表，当需要创建任务时，便可从这个链表中拿出一个空的任务控制块，来设置任务的相关信息</a>。所有创建好的任务控制块会连接到另外一个任务控制块链表中，当系统进行调度时，便会从这一链表中选出任务块来运行任务。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务的创建最关键就是设置任务的栈，本系统中每个任务都拥有一个固定的栈，栈空间的大小由开发者定义，毕竟不同开发板其内存资源也是不同的。栈空间主要用于切换任务时，保存当前任务在CPU上寄存器的数据，以便将来恢复当前任务继续运行。当任务首次创建时，PC寄存器会指向当前任务的函数入口地址，当函数被调度运行时，便可跳到对应的函数，开始执行程序。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当设置好任务的栈后，还需要把任务块连接到任务控制块链表中，这样任务的状态就可以设置为就绪，等待系统调度运行了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务链表和任务块的基本模型如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-7 任务链表图<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6.4 任务的挂起和恢复<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个普通任务都可以挂起任务自身或者其它任务，当任务被挂起时，就会处于挂起态，这时，不论任务的优先级是什么，都不会得到系统的调度运行。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被挂起的任务只能通过其它任务来恢复，只要把被挂起任务的状态清掉，那么该任务就可继续参与到系统的调度中。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6.5 任务删除<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务删除操作可以删除其它任务或者删除任务自身，为了让被删除的任务能够释放自身所占用的资源，我们可以先发送一个删除任务的消息给对方，当对方收到这个消息后，就可以进行适当的步骤后再删除自身，这种方法要比直接删除任务更安全、灵活。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7 中断服务模块的设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断服务模块主要为操作系统提供中断响应机制，当系统接收到外部中断请求后，会停止当前正在运行的任务，从而转到中断服务子程序进行中断处理。本系统暂时只需要外部中断请求IRQ，因此只讲解外部中断的请求过程，对于其它中断比如快速中断FIQ等可以参考S3C6410芯片手册进行编写。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个任务需要打开中断后才能响应中断，在任务堆栈的初始化时，应当把每个任务的状态寄存器即CPSR设为0x0000001F，即处于系统工作模式并打开外部中断，这样当系统产生中断时，就会跳转到相应的中断处理函数。本系统的主要中断处理函数有时钟定时器中断处理和按键中断处理。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时钟定时器主要是完成系统在每个时钟节拍需要做的工作，我们首先需要设置系统时钟的节拍，比如系统时钟节拍为10ms，即每秒中断10次。这里需要根据S3C6410芯片手册，设置相应的时钟寄存器，把设置的值写入到相应的位即可。由于ARM11采用的中断向量的方式来设置中断，所以中断设置比较简单，只需把中断的处理函数地址写到对应的向量位，那么当中断产生时，就会自动进入中断处理函数，进行中断处理。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时钟定时器的中断处理函数主要完成的工作为：给系统的时钟计数器加1，然后遍历任务控制链表，把所有延时任务的延时器减1，如果延时任务的延时器变为0，还要将该任务的延时状态清零。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理中断的函数基本都是使用ARM汇编来完成，主要是进入中断前，需要保存CPU的寄存器数据到当前任务的栈空间中，然后在进入中断处理函数。退出中断后，需要把任务栈中的寄存器数据恢复到处理器中，从而使得任务能继续运行。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按键中断也是首先设置好相应的中断位，然后设置中断处理函数的地址，当有按键按下时，系统就会跳到对应的按键的中断处理函数。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8 时间管理模块的设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间管理模块可以提供任务的延时和系统时钟节拍的功能。任务的延时主要根据时钟节拍来计算出任务所需延时的时钟节拍数，本系统的时钟节拍为10，即1秒会进行10次中断，时间片为100ms。如果任务需要延时1秒，那么延时的节拍数即为10。任务进入延时后，系统应当重新引发一次调度，运行下一个就绪任务。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次时钟中断，系统都会检查任务块，对于有延时的任务块，系统会减去1个延时节拍数，当延时节拍数变为0，那么任务块的延时状态就会清零。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，还需记录系统从开始运行到至今已经经过多少个时钟节拍，因此，系统还有一个时钟计数器，每次时钟节拍中断时都会加1。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9 内存管理模块的设计<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存管理功能是操作系统内核中一个重要的功能，本小型嵌入式操作系统提供一个比较简单的内存管理功能，任务能在运行时申请内存空间，当任务不需要这些空间时，可以释放归还给操作系统。内存管理的技术比较多，从操作系统教程就可知道有地址空间与重定位、分区管理、分页技术、虚拟存储管理等等。<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="61">其中分区的管理算法简单，易于实现，但碎片问题严重，内存利用率低[11]</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="62">本系统采用比较简单的固定分区法来实现内存的管理。固定分区法就是内存中分区的个数固定不变，各个分区</a><a href="javascript:;" class="yellow cqvip-jianceorgan-paperreportpart" partid="63">的大小固定不变，根据大小的不同还可分为等分方式和差分方式，所谓等分，就是各个分区大小相同，所谓差分，就是分区具有不同大小[12]</a>。利用等分方式，实现方法简单，需要处理的开销也很小，但缺点也很明显，任务申请的内存空间一定要在分区的大小之内，否则将会引起灾难性的结果。对于更好的分区方法，将留到下阶段的改进。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用固定分区法，我们可以通过定义一个二维数组就能实现内存分区，比如一个8位的数组MxN，内存分区的大小为8*M*N个字节，总共可以分为M个内存块，每个内存块有N个字节，每次任务申请的内存都需要小于N个字节。如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-8 固定分区<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种分区方法虽然比较粗糙，内存的利用率低，但实现简单，开销小，实时性也较好。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="64">有了内存分区后，我们还需要一个内存控制块来管理内存分区里的内存块，实现真正的内存分配。内存控制块需要设置内存分区的起始地址、内存块的大小、内存块的数量，已经分配出去的内存块数量等信息</a>。对于各个内存块，我们需要把它们连接成一个链表，那么分配内存时，就可直接在链表中取出该内存块给任务，任务释放内存时，只需将该内存块连接回链表中即可。如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图3-9 内 存 控 制块和内 存 分区的关系<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10 本章小结<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章首先介绍了整个嵌入式操作系统的设计目标和一个总体的结构，把整个系统功能划分成4个模块，引导模块、系统更新模块、串口通信模块和操作系统模块，然后阐述了各个模块的设计思路。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统实现<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1 系统开发环境的搭建<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嵌入式应用的开发一般都是采用主机与开发板结合的交叉开发模式，因为嵌入式设备大多没有操作系统，即使是配有操作系统，一般情况下也是没有相应的编译和开发工具，不足以用来开发软件，也就是说开发板上不能自行编译软件程序后运行。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="65">因此，需要在主机（PC机）上先为开发板搭建对应的开发环境，然后编译出对应的应用程序，最后烧写到开发板上，才能正常运行</a>。所以一般用到的交叉开发模式为：在主机上编辑程序代码、编译成对应开发板上的应用程序，然后烧写到开发板上，最后在开发板上运行和验证应用程序。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本设计里，主机是指PC机，开发板也就是OK6410开发板，所开发的嵌入式操作系统首先也是在主机上进行编写程序，然后通过交叉编译后再把目标程序烧写到OK6410开发板上，最后是验证该系统的正确性。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="66">嵌入式的开发环境既能在Windows下搭建，又能在Mac OS或Linux下搭建，由于本设计使用</a>Linux操作系统作为开发的平台，因此这里只讲解在Linux下如何搭建相应的开发环境，对于其它操作系统也是类似，这里就不讲解了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本设计里搭建的嵌入式开发环境只要配置相应的交叉开发工具链即可，因为平常在PC上所使用的编译工具一<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="67">般都是gcc、ld等，它们编译出来的程序一般都是运行在x86平台上的，对于ARM平台上的嵌入式设</a>备来讲，是不能运行x86的应用程序，因此需要使用交叉编译工具来生成ARM平台上的目标程序，这里的交叉编译工具就是arm-linux-gcc、arm-linux-ld等。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本设计里所使用的主机操作系统为Fedora 20 Xfce，所使用的交叉编译工具链是Sourcery CodeBench Lite 2013.11-24（GCC版本号为4.8.1）。可以到http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/ 处下载最新的ARM交叉编译工具链。注意，这里ARM的交叉工具链有两个版本：EABI和GNU/Linux，这里的GNU/Linux版<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="68">本是用来编译嵌入式Linux内核或Linux应用的，EABI版本适用于编译自己的嵌入式操作系统或</a>应用，不能用于编译Linux应用，由于本文设计的嵌入式操作系统不涉及Linux，因此本设计选择EABI版本来作为工具链。此处下载到的安装包格式为.tar.bz2。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Fedora 20里安装交叉编译工具链的推荐步骤为：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在/usr/local/目录里创建一个名为CodeSourcery的文件夹（非必须，只是推荐）。命令为：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdir /usr/local/CodeSourcery<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解压下载的安装包。命令分为2步，第一条命令将把.tar.bz2解压为tar包，然后再使用第二条命令解压tar包得到安装的文件夹：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bunzip2 arm-2013.11-24-arm-none-eabi-i686-pc-linux-gnu.tar.bz2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tar -xf arm-2013.11-24-arm-none-eabi-i686-pc-linux-gnu.tar<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解压后得到arm-2013.11的文件夹，本课题里把它重命名为arm-none-eabi，并移到第一步所创建的文件夹CodeSourcery下，命令为：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mv arm-2013.11 /usr/local/CodeSourcery/arm-none-eabi<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="69">把交叉工具链的目录添加到系统环境变量中，具体为编辑用户目录下的.bashrc文件，命令为：</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim ~/.bashrc<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后添加bin目录的路径和lib目录的路径，如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PATH=$PATH:/usr/local/CodeSourcery/arm-none-eabi/bin<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/CodeSourcery/arm-none-eabi/lib<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="70">最后是输出环境变量，保存修改的.bashrc文件即可：</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export PATH<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，交叉编译链就配置好了，可以使用命令让修改的环境变量立即生效：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source ~/.bashrc<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后可以使用下面命令测试一下交叉编译工具链是否安装正确：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arm-none-eabi-gcc -v<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果出现如下图2-7的GCC版本号，那么基本的开发环境就搭建好了，可以开始编写和编译ARM应用程序了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-1 ARM交叉编译工具链版本号<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2 任务管理模块的实现<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.1 任务控制块的定义及初始化<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据第3章任务控制块的设计，具体的代码实现如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-2 任务控制块的定义<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中tcb_stk_ptr就是每个任务的栈指针，该栈指针指向每个任务的栈地址；tcb_prio是<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="71">任务的优先级号，即任务号，tcb_next和tcb_prev分别指向下一个和前一个任务控制块，t</a>ask_status是任务的状态，tcb_delay为任务的延时节拍，tcb_del_req是任务的删除标志。其中定义了3种任务状态，就绪、延时和挂起，定义如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-3 任务状态的定义<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务控制定义好后，还需要定义任务控制块的链表指针、任务块的变量，当前运行任务块的指针、最高优先级就绪任务的指针，优先级有序表等，如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-4 任务控制块的相关变量<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="72">当定义好任务控制块的所有变量后，需要把空任务块连接成空任务块控制链表，主要代码如下图所示</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-5 空任务块链表<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3.2 任务的创建<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务控制块初始化后，系统会创建系统任务，然后才会创建开发者定义的普通任务。系统和普通任务都是通过create_task()函数来创建。create_task()需要四个参数，分别是任务函数的入口地址，任务函数的参数，栈顶地址和任务的优先级号。首先函数会判断任务的优先级号是否在正常范围内，即0到最小优先级号之间，接着判断该任务号是否已经被其它任务申请了，这里是通过os_tcb_prio_table[prio]来判断，如果为NULL，则说明此任务号还没被使用，接着会初始化该任务的栈和任务块，代码如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-6 create_task()函数部分代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中init_task_stack()和init_tcb()是创建任务的重点函数，init_task_stack()用来初始化任务的栈空间，即从栈顶地址分配寄存器空间，用于保存任务调度时的任务现场数据，代码如下图所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-7 init_task_stack()函数代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_tcb()函数主要是从os_tcb_free_list里取出一个空任务块，把它连接到任务控制块链表中，接着设置任务相应的值后，该任务就处于就绪运行的状态了，代码如下。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-8 init_tcb()函数部分代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当创建的任务进入就绪状态后，会返回到create_task()函数中继续运行，此时create_task()函数会判断系统是否已经在运行，如果系统已经运行，则会进入任务调度函数进行任务调度。如果系统还没有开始运行，则会返回，直到start_os()函数运行后才开始调度多任务。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3.3 多任务的调度<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统开始运行前，会执行start_os()函数，才会开始执行多任务的调度。start_os()函数首先从优先级有序表找出就绪的最高优先级任务，然后开始运行就绪任务，代码如下。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-9 start_os()函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，sched_new()函数负责找出最高优先级就绪的任务，代码如下。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-10 sched_new()函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找最高优先级就绪任务的算法比较简单，直接从os_tcb_prio_table开始从0往下找，因为优先级越高的任务，其任务号越低，所以，只要os_tcb_prio_table[prio]不为NULL，就能知道该任务号是存在的，所以我们就可以通过该任务的task_status来判断是否为就绪，如果就绪，则把os_prio_high_ready设为该任务号。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_task()函数运行就绪任务，将任务从栈寄存器中恢复数据，就可以开始运行了，本函数通过ARM汇编来编写，代码如下图4-11和4-12所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-11 start_task()函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-12 restore_task()函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统开始运行后，就由sched()函数来专门负责任务的调度了，比如正在运行的任务进入延时后，就会调用sched()函数来重新进行任务的调度运行，代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-13 sched()函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="73">该函数首先判断当前运行的任务与最高优先级的就绪任务是否相同，如果不相同，则进行任务的调度，选择最高优先级就绪的任务来运行</a>。切换任务由switch_task()函数来完成，该函数使用ARM汇编来编写，主要先保存当前任务的数据，然后恢复最高优先级就绪任务的栈寄存器数据即可恢复现场来运行，主要代码如下。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-14 switch_task()函数主要代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务的调度主要由选择最高优先级就绪任务和切换任务这两部分来完成，本设计只是用比较简单的算法来实现基本任务调度原理，因此没有复杂的调度算法，而切换任务只需首先把当前任务的数据保存起来，然后把最高优先级就绪任务的地址保存到当前栈指针SP处，就能由ldr指令恢复现场数据了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3.4 任务的挂起和恢复<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;挂起任务，就能让任务停止运行。挂起任务的函数为suspend_task()，调用该函数，可以挂起任务自身，也可以挂起其它有效任务。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="74">如果需要挂起任务自身，传递的参数为OS_PRIO_SELF，其它任务只需传递相应的任务号即可</a>。该函数会改变任务的状态为TASK_SUSPEND，从而使它不能就绪而停止运行。如果挂起的任务是当前任务自身，改变任务状态后，还会调用sched()来进行重新的任务调度，选择最高优先级就绪任务来进行运行。基本代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-15 任务挂起函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="75">任务的恢复只能通过其它任务来恢复被挂起的任务，函数为resume_task()。该函数将任务状态</a>的TASK_SUSPEND清零，如果该任务没有设置延时状态，该位清零就会变成就绪状态，也就是TASK_READY，同时会进行新的任务调度，代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-16 任务恢复函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务的挂起和恢复相对简单，只要设置任务状态的相应位为对应的状态即可，设置后只要调用sched()函数就能进行新的任务调度了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3.5 任务的删除<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务删除可以删除其它任务或者删除任务自身，首先要调用delete_task_request()来发送删除任务的消息，被删除任务接受到删除消息后，调用delete_task()来删除任务自身。删除任务首先把任务挂起，并把延时时间设为0，避免被调度。接着把该任务块从os_tcb_list中归还到os_tcb_free_list中，再引发新的任务调度。代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-17 delete_task_request()部分代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-18 delete_task()部分代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4 中断服务模块的实现<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于系统启动时，本设计就已经设置外部中断服务程序的入口地址，所以当发生外部中断IRQ后，系统会跳转到irq_isr函数处执行中断处理。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="76">执行中断处理前，首先需要保存任务现场，然后跳转到中断处理程序处理中断，处理完毕后，退出中断，恢复任务</a>。核心代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-19 irq_isr函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中handle_irq用来跳到开发者定义的中断处理函数，代码如下。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-20 handle_irq函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;退出中断，由exit_interrupt函数来完成。退出中断前，该函数会进行一次任务调度，如果没<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="77">有更高优先级就绪的任务，那么会恢复被中断的任务接着运行，否则会去运行更高优先级就绪的任务，代码如下所示</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-21 exit_interrupt函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="78">如果没有更高优先级就绪任务，那么函数就会返回到irq_isr函数处，接着恢复被中断的任务去运行，</a>如果此时有了更高优先级就绪的任务，那么就会执行interrupt_switch_task()函数来运行更高优先级就绪任务。interrupt_switch_task()首先得出更高优先级就绪任务的任务块指针，接着恢复寄存器数据就能开始运行了，代码比较简单，如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-22 interrupt_switch_task()函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断服务模块还有一个重要的功能，就是能提供开中断或关中断功能，系统默认是打开中断的，但有时一些代码不能受到中断的影响，因此需要关闭中断，那些不希望被中断的代码段叫做临界段。打开和关闭中断涉及到ARM指令，因此这部分代码是通过ARM汇编来编写的。本系统通过enter_critical()和exit_critical()两个函数来退出和打开中断，这两个函数其实是用宏定义来实现，代码如下。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4-23 退出和打开中断宏定义<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;退出中断首先需要保存CPSR状态寄存器，由save_cpsr()来完成，然后关闭中断即可。恢复中断由restore_cpsr()来完成，只需要恢复原先保存的CPSR寄存器即可。代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-24 保存和恢复CPSR寄存器代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5 时间管理模块的实现<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时钟中断服务程序为time_tick()，该函数的主要功能是给时间计数器计数，接着遍历所有任务控制块，如果该任务有延时，就把延时计数器减1，并判断计数器是否减为0，如果是，还需要把该任务的延时状态给清零。代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-25 time_tick()函数代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本系统提供多个函数接口给开发者调用，比如delay()函数，能够让当前任务休眠指定个时钟节拍，sleep()函数，让当前任务休眠指定的秒数，msleep()让任务休眠指定的毫秒数，sleep_hmsm()能用时、分、秒、毫秒来作为传递参数进行休眠延时。其中sleep()、msleep()、sleep_hmsm()函数都是先把时间转化为毫秒数，然后计算出休眠的时间节拍后，再调用delay()函数来进入休眠，所以delay()函数是所有休眠函数的最终调用函数，delay()函数的核心代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-26 delay()函数代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;休眠函数msleep()的代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-27 msleep()函数代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;剩下的sleep()和sleep_hmsm()函数代码都是比较简单，都是把休眠的时间转化为毫秒，再调用msleep()就可以了。任务进行休眠后，会进行一次新的任务调度，从而运行最高优先级就绪任务，延时任务会在时间中断服务程序里减去延时计数器，当延时计数器减为0时，如果任务没有被挂起，那么该任务就会再次成为就绪任务，等待调度。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务也可以取消延时，由其它任务进行调用cancel_delay()函数从而取消被延时的任务，并进行一次新的调度。取消延时的函数如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-28 cancel_delay()函数<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.6 内存管理模块的实现<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存控制块主要用来记录内存分区的状态信息，其定义如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-29 内存控制块的定义<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="79">内存控制块中mem_addr指向内存分区的起始地址，mem_free_list指向下一个内存块地</a>址，block_len表示内存块的长度，即大小，num_blocks表示内存块的个数，num_free表示空闲的内存块的数目。当系统初始化时，首先会把内存分区内的各个内存块连成一个链表，当任务需要内存块时，就从链表中取出内存块，返回给任务。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-30 create_mem()函数核心代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;核心代码如上图所示，以定义的u8 array[10][50]为例，内存分区就是array这个数组，其中有10个内存块，每个内存块大小为50个字节，所以每次分配内存，就是把array[0]、array[1]、array[2]的地址返回给调用者。因此，还需要把全部内存块连接在一起，这里可以把array[0]指向array[1]，array[1]指向array[2]，以此类推，然后内存控制块的mem_addr指向内存分区的首地址，也就是array，mem_free_list指向内存块，每申请一次内存，mem_free_list就指向下一个内存块，从而达到分配内存的目的。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当内存分区创建好后，就可以在任务里申请和释放内存空间了。这里需要要注意，申请内存空间，并不像一般程序里申请多少个字节就能获取多少个字节的空间，在本嵌入式操作系统里，申请的空间必须小于或等于内存块的大小，如果定义的内存分区为u8 array[10][50]，那么每次申请的内存空间绝对不能超过50个字节，而且只能申请10次内存空间。如果申请的空间超过内存块的大小，那么只会返回NULL指针。申请内存块使用get_mem()函数，该函数首先判断申请内存的大小，然后判断该内存分区是否还有空余的内存块，如果有，则把该内存块的地址返回给调用者。具体代码如下所示。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-31 get_mem()函数代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;释放内存的函数为free_mem()，该函数首先把释放的内存块指向内存分区里的空余内存块，然后把mem_free_list指向该内存块，从而达到归还到内存分区中。释放内存空间代码如下。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4-32 free_mem()函数代码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.7 本章小结<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章主要详细讲解了操作系统模块的实现代码，也就是整个小型嵌入式操作系统的内核代码，包括系统变量的定义，任务的创建和调度等功能的实现，中断服务功能的实现，时间管理和内存管理的功能实现，这四个模块组合起来，就是一个简单操作系统的基本实现。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统测试<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1 测试环境<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）主机配置<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 		处理器：Intel Core i3-3217U，1.8GHz<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存：4GB<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;硬盘：320GB<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作系统：Windows 7旗舰版<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）开发板配置<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;芯片：三星S3C6410，ARM 11，533 MHz<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存：DDR 256MB<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAND Flash：4GB<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2 测试结果及分析<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="80">下面针对操作系统的各个功能模块进行测试</a>。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）任务管理模块<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表5-1 任务管理模块的测试用例和结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试用例	操作描述	预期结果	实际结果	测试状态<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1-1	使用任务创建函数，分别创建2个任务，并显示出任务的栈地址和函数的入口地址。	创建相应优先级的任务，并打印出该任务的栈地址和函数入口地址。	如图5-1所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1-2	进行2个任务的调度，每个任务打印出各自的优先级号后休眠1秒。	2个任务各自打印自己的优先级号，然后延时1秒。	如图5-2所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1-3	在用例1-2的基础上，当系统运行100个时钟节拍后，创建一个更高优先级的任务，观察3个任务的调度次序。	当优先级更高的任务创建后，更高优先级的任务会比2个优先级低的任务更先运行。	如图5-3所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1-4	两个任务，当系统时钟节拍为10时，挂起一个任务；当时钟节拍为50时，恢复任务。	一开始两个任务分别打印自己的优先级号，当一个任务被挂起后，只有一个任务在运行，当被挂起的任务恢复后，才有两个任务运行。	如图5-4所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1-5	两个任务，当系统时钟节拍为20时，删除一个任务。	删除任务后只有一个任务在运行。	如图5-5所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例 1-1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建任务函数代码如下所示，分别创建两个优先级为5和6的任务：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create_task(task_5, NULL, &task_stk[5][STK_SIZE - 1], 5);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create_task(task_6, NULL, &task_stk[6][STK_SIZE - 1], 6);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下图所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-1 用例 1-1 运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例1-2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建2个任务分别打印自己的优先级号，并休眠1秒，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prio_t prio;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	while (1) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		prio = os_tcb_current_ptr-&gttcb_prio;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print("[app] I am task ");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print_int(prio);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print("\n");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		sleep(1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下图所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-2 用例1-2 运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例1-3<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统运行节拍超过100后，创建一个优先级为1的任务：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (is_created == 0 && get_os_time() &gt= 100) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create_task(task_1, NULL, &task_stk[1][STK_SIZE - 1], 1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		is_created = 1;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下图所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-3 用例1-3运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例1-4<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级为5和6的两个任务，当时钟节拍为10时，任务5挂起任务6，当时钟节拍为50时，任务5恢复任务6，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (get_os_time() == 10)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		suspend_task(6);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	else if (get_os_time() == 50)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		resume_task(6);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-4 用例1-4运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例1-5<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级为5和6的两个任务，当系统时钟节拍为20时，删除优先级为6的任务，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (delete_task_request(OS_PRIO_SELF) == OS_TASK_DEL_REQ) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print("I am going to delete myself\n");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		delete_task(OS_PRIO_SELF);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-5 用例1-5运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）时间管理模块<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表5-2 时间管理模块的测试用例和结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试用例	操作描述	预期结果	实际结果	测试状态<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2-1	创建一个任务，打印自己的优先级号后延时2秒。	任务每隔2秒打印一次信息。	如图5-6所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2-2	创建一个任务，打印自己的优先级号后延时500毫秒。	任务每隔500毫秒打印一次信息。	如图5-7所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2-3	创建2个任务，当高优先级任务打印自己的优先级后延时50秒，当时钟节拍为30时，低优先级任务取消高优先级任务的延时。	高优先级任务运行一次后就进入延时，当时钟节拍为30时，高优先级任务取消延时，继续运行。	如图5-8所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例2-1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个优先级为5的任务，每次打印自己的信息后延时2秒，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (1) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	prio = os_tcb_current_ptr-&gttcb_prio;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	uart_print("[app] I am task ");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	uart_print_int(prio);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	uart_print("\n");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	sleep(2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-6 用例2-1运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例2-2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个优先级为5的任务，每次打印自己的信息后延时500毫秒，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (1) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	prio = os_tcb_current_ptr-&gttcb_prio;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	uart_print("[app] I am task ");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	uart_print_int(prio);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	uart_print("\n");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	msleep(500);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-7 用例2-2运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例2-3<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级为5和6的任务，优先级为5的任务运行一次后延时50秒，优先级为6的任务当时钟节拍为30时，取消优先级为5的任务的延时，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (1) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		prio = os_tcb_current_ptr-&gttcb_prio;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print("[app] I am task ");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print_int(prio);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print("\n");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		if (get_os_time() == 30)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			cancel_delay(5);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		sleep(1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下所示：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-8 用例2-3运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）内存管理模块<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表5-3 内存管理模块的测试用例和结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试用例	操作描述	预期结果	实际结果	测试状态<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3-1	创建2个任务，1个任务在时钟节拍为10时申请一个内存块，另一个任务在时钟节拍为20时申请一个内存块，申请的内存块写进当前的系统时钟节拍，并打印出当前内存块的信息。	2个任务各申请一块内存，并显示内存块的信息。	如图5-9所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3-2	在用例3-1的基础上，当时钟节拍为50时，2个任务都释放自己申请的内存块。	2个任务释放自己占用的内存块。	如图5-10所示	通过<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例3-1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建2个优先级分别为5和6的任务，在时钟节拍为10和20的时候申请一个内存块，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (get_os_time() == 10) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		ptr = get_mem(BLOCK_LEN);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		if (ptr != NULL) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			uart_print("[app] Task ");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			uart_print_int(prio);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			uart_print(" used one memory, content is: ");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			*ptr = get_os_time();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			uart_print_int(*ptr);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			uart_print("\n");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-9 用例3-1运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用例3-2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当时钟节拍为50时，两个任务释放各自申请的内存，代码如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (get_os_time() == 50) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print("[app] Task ");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print_int(prio);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		uart_print(" release one memory\n");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		free_mem(ptr);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下：<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图5-10 用例3-2运行结果<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3 本章小结<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章简单列出了系统测试的基本环境，接着把系统的各个模块和功能做了测试，并把相应的结果显示出来，系统测试的结果表明系统的各个功能模块是能按照预期结果正确运行的。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结    论<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过在ARM平台上设计一个小型的嵌入式操作系统，能够加深对操作系统基本原理的理解，又能避免涉及过多的传统计算机的硬件知识。在本设计过程中，虽然遇到过很多底层硬件代码编写和系统设计的问题，但最终还是把一个简单的操作系统的基本雏形做出来了。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本系统具有基本的多任务调度和简单的内存管理功能，采用按优先级抢占式的调度算法，优先级最高的任务总能第一时间运行，多任务的调度主要靠中断服务和时间管理来共同完成。每个系统时钟节拍的中断，系统都会对每个任务控制块进行检查，退出中断时会查找最高优先级的就绪任务，从而保证最高优先级的任务的运行。任务的切换是本系统的重点，需要保存当前任务的寄存器数据到栈中，然后再把需要切换的任务的栈中的数据恢复到CPU的寄存器中，就可以完成任务的切换了。<a href="javascript:;" class="red cqvip-jianceorgan-paperreportpart" partid="81">任务的管理功能除了任务的创建和调度切换外，还能进行挂起任务、恢复任务、删除任务的操作。时间的管理功能包括任务的延时、取消延时、获取系统运行时间和设置系统运行时间</a>。内存管理功能采用了比较简单的方法来完成，主要把二维数组划分为不同的内存块来进行分配和管理，任务能在运行时申请需要的内存和释放不需要的内存。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然本系统实现了操作系统的最基本的功能，但是还有很多不足和需要改进的地方，像文中里面谈到的任务优先级的设计、任务的调度算法、内存的管理和分配等，这些都是能够优化改善的，希望能在下一阶段进行更进一步的改进。此外这个内核延还有许多能伸出来的功能，比如任务的同步和通信、信号量、事件的管理等。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过本次的毕业设计，我进一步的了解操作系统基本的实现过程，虽然过程比较繁琐和复杂，但看到自己设计的系统能运行起来，真的感到无比的欣悦。今后还要学习更多的操作系统的设计思路和实现过程，做一个即完善又实用的系统。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			</div>		</div>	</div></div><div style="display:none;"><div id="report_part_1"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">75%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">在</i><i class="blue">学习</i><i class="black">和</i><i class="blue">设计操作系统的过</i><i class="black">程</i><i class="black">中</i>，<i class="black">能</i><i class="blue">加深</i><i class="black">我们</i><i class="blue">对操作系统基本原理的理解</i>，<i class="blue">对计算机系统的</i><i class="black">工</i><i class="blue">作过</i><i class="black">程也</i><i class="black">会更</i><i class="black">加清晰</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">通<font color="red">过学习</font>使学员掌握<font color="red">计算机操作系统的设计基本原理</font>及组成;<font color="red">计算机操作系统的基本</font>概念...联想日常生活中熟悉的管理示例反复体<font color="red">会操作系统的</font>管理方法,以<font color="red">加深对</font>问题<font color="red">的理解</font>。...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《计算机操作系统教学设计方案(0809)》</li><li>入库时间：2010-04-02</li></ul></div><div id="report_part_2"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">73.08%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">嵌入式系统是</i><i class="black">从</i><i class="blue">20世纪70年代微处理器出现后发展</i><i class="black">起来</i><i class="black">的</i>，<i class="black">当</i><i class="blue">时的系统结构和功能相对</i><i class="black">单</i><i class="black">一</i>，<i class="blue">主要</i><i class="black">用于工业控制[1]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">网络技术高速<font color="red">发展的后</font>PC<font color="red">时代</font>,<font color="red">嵌入式系统</font>已经广泛地...然而直到<font color="red">20世纪70年代</font>,<font color="red">微处理器的</font>问世,才<font color="red">出现</font>真正...这一阶段<font color="red">嵌入式系统的主要</font>特点是:<font color="red">系统结构和功能相对</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《基于ARMμClinux的灌溉控制系统的构建 - 豆丁网》</li><li>入库时间：2013-03-11</li></ul></div><div id="report_part_3"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">73.33%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">嵌入式操作系统</i>（<i class="blue">Embedded Operating System</i>，<i class="blue">EOS</i>）<i class="blue">是嵌入式系统的核心部分</i>，<i class="black">与通用</i><i class="blue">计算机操作系统</i><i class="black">相比</i>，<i class="black">具有专用性</i>、<i class="black">可裁剪</i>、<i class="black">易移植</i>、<i class="black">高</i><i class="black">可靠等特点</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">式系统是计算机系统的</font>一种,因而<font color="red">嵌入式系统</font>也可以分为软硬件两<font color="red">部分</font>,和桌面<font color="red">计算机系统</font>一样,<font color="red">嵌入式操作系统</font>(<font color="red">Embedded Operating System</font>,<font color="red">EOS</font>)<font color="red">是嵌入式</font>软件<font color="red">系统的核心部分</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式操作系统 - 豆丁网》</li><li>入库时间：2009-05-12</li></ul></div><div id="report_part_4"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.04%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">不同</i><i class="blue">的嵌入式操作系统</i><i class="black">包含</i><i class="black">不同</i><i class="black">的基本</i><i class="blue">功能</i><i class="black">组件</i>，<i class="black">但</i><i class="blue">都具备一个</i><i class="black">基本</i><i class="blue">的内核</i>，<i class="black">这</i><i class="blue">个内核主</i><i class="black">要</i><i class="blue">的功能</i><i class="black">就</i><i class="black">是提供多</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">设备驱动程序为主。2．2<font color="red">嵌入式操作系统</font>2．2．1<font color="red">嵌入式操作系统</font>应<font color="red">具备的功能</font>对于<font color="red">一个嵌入式系统</font>来说，并<font color="red">不是</font>所有通用<font color="red">操作系统内核的功能都</font></p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《嵌入式操作系统uclinux裁剪技术研究 》</li><li>作者：周彩贞</li><li>专业：计算机应用技术</li><li>年份：2007</li><li>机构：武汉理工大学</li></ul></div><div id="report_part_5"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.64%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">-Ⅱ</i><i class="blue">的内核就</i><i class="black">相</i><i class="blue">对简单</i>，<i class="black">而</i><i class="blue">嵌入式Linux就和桌面</i><i class="black">版</i><i class="blue">的Linux</i><i class="black">差不多了</i>，<i class="black">因此</i><i class="blue">功能</i><i class="black">也相</i><i class="black">对更强大</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">一个操作系统<font color="red">内核的</font>主要<font color="red">功能就</font>是管理硬件资源<font color="red">和对</font>...<font color="red">嵌入式Linux</font>是指应用于<font color="red">嵌入式</font>系统<font color="red">的Linux</font>,与通用系统...从<font color="red">桌面Linux</font>到<font color="red">嵌入式Linux</font>只需要很<font color="red">简单的</font>过程,像火狐...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式Linux内核研究 - 豆丁网》</li><li>入库时间：2012-12-21</li></ul></div><div id="report_part_6"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">69.57%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">嵌入式系统的核心硬件</i><i class="black">就</i><i class="blue">是嵌入式处理器</i>，<i class="blue">嵌入式处理器的</i><i class="black">体</i><i class="blue">系结构</i><i class="black">如果按不</i><i class="blue">同的内核系</i><i class="black">列可以分为51</i>、<i class="black">A</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">掌握<font color="red">嵌入式系统硬件结构</font>; 了解<font color="red">嵌入式处理器</font>技术指标...<font color="red">嵌入式处理器是嵌入式系统硬件的核心</font>,运行<font color="red">嵌入式系统</font>...基本上是相<font color="red">同的</font>,<font color="red">嵌入式处理器的内核</font>和普通<font color="red">处理器的</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式系统原理-第3章 嵌入式处理器v3 - 豆丁网》</li><li>入库时间：2013-07-05</li></ul></div><div id="report_part_7"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">78.26%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">ARM</i><i class="black">既</i><i class="black">是一间</i><i class="blue">公司的名字</i>，<i class="blue">也是</i><i class="black">一系列处理器</i><i class="blue">的名称</i>。<i class="blue">ARM的</i><i class="black">全</i><i class="blue">称是Advanced RISC Ma</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red"> RISC Mac</font>hi<font color="red">ne</font>s，简<font color="red">称ARM。</font>有趣<font color="red">的是</font>这家<font color="red">公司的名字也是Advanced RISC Mac</font>hi<font color="red">ne</font>sLtd．，简<font color="red">称ARM</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《ARM小记》</li><li>作者：杜洋</li><li>出处：《无线电》 2010，(4)：14 -18</li><li>机构：不详</li></ul></div><div id="report_part_8"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">81.4%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">ARM处理器的</i><i class="black">主要特</i><i class="blue">点是功耗低</i>、<i class="black">省电</i>、<i class="blue">性能</i><i class="black">强</i><i class="black">大</i>、<i class="blue">成本低</i>，<i class="black">拥有</i><i class="blue">16位Thumb</i>、<i class="blue">32位ARM和Th</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">ARM处理器的3大</font>关键优点(小体积<font color="red">、低功耗、成本低、</font>高<font color="red">性能</font>;<font color="red">16位</font>/<font color="red">32位</font>双指令集... 1.2 <font color="red">ARM</font>指令<font color="red">和Thumb</font>指令的区别 <font color="red">Thumb</font>指令集大多数是常用<font color="red">的32位ARM</font>指令的子集...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《基于ARM内核的ARM与Thumb混合代码的生成_中华文本库》</li><li>入库时间：2004-04-01</li></ul></div><div id="report_part_9"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">72.09%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">的内</i><i class="blue">核采用</i><i class="black">不同</i><i class="blue">的体系结构</i>，<i class="black">像经典</i><i class="blue">处理器的ARM7采用的</i><i class="black">是</i><i class="blue">ARMV4T的结构</i>，<i class="black">Cortex-</i><i class="blue">A采用的</i><i class="black">是</i><i class="blue">ARMV7</i><i class="black">-</i><i class="blue">A的结构</i>，<i class="black">具</i><i class="black">体可到</i><i class="blue">ARM</i><i class="black">公司</i><i class="black">的官网查看</i><i class="blue">ARM</i><i class="black">内</i><i class="blue">核采用的体系结构</i><i class="black">版本</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">ARM</font>微<font color="red">处理器核</font>心以及<font color="red">体系结构的</font>发展历史 1.<font color="red">ARM7处理器</font> <font color="red">ARM7处理器采用</font>了<font color="red">ARMV4T</font>(冯·诺依曼)<font color="red">体系结构</font>,这种<font color="red">体系结构</font>将程序指令...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM版本 - yangquanwa的日志 - 网易博客》</li><li>入库时间：2012-10-07</li></ul></div><div id="report_part_10"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">73.75%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">ARM处理器一般</i><i class="black">拥</i><i class="blue">有2种工作状态</i><i class="black">和</i><i class="blue">7种工作模式</i>，<i class="black">因</i><i class="blue">为ARM处理器</i><i class="black">拥</i><i class="black">有16/</i><i class="blue">32位指令集</i>，<i class="black">因</i><i class="blue">此ARM处理器可</i><i class="black">以</i><i class="blue">在ARM</i><i class="black">和Thumb</i><i class="black">及Thumb-</i><i class="black">2这</i><i class="blue">两种工作状态间切换</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">ARM</font>架构<font color="red">处理器及ARM处理器7种工作模式ARM处理器状态</font>、<font color="red">指令集ARM</font>微<font color="red">处理器</font>的<font color="red">工作状态一般有两种</font>,并<font color="red">可在两种状态</font>之<font color="red">间切换</font>:第<font color="red">一种为ARM状态</font>,此时<font color="red">处理器</font>执行<font color="red">32位</font>的字...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM架构处理器及ARM处理器七种工作模式--嵌入式系统开发基础,入门...》</li><li>入库时间：2011-04-01</li></ul></div><div id="report_part_11"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">71.74%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">ARM状态</i><i class="black">就是</i><i class="blue">ARM处理器</i><i class="black">完全</i><i class="blue">工作</i><i class="black">在</i><i class="blue">32位指令</i><i class="black">下</i><i class="blue">的状态</i>，<i class="black">在此</i><i class="blue">状态</i><i class="black">下</i><i class="blue">的指令</i><i class="black">长度均为</i><i class="blue">32位</i>。<i class="blue">Thum</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">一、<font color="red">ARM处理器的</font>两种<font color="red">工作状态</font>: 1、<font color="red">ARM状态</font>:<font color="red">32位</font>,<font color="red">ARM状态</font>执行字对齐<font color="red">的32位ARM指令。</font> 2、<font color="red">Thum</font>b<font color="red">状态</font>,16位,执行半字对齐的16位 3、用Bx Rn<font color="red">指令</font>来进行两种<font color="red">状态的</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM的2种状态和7种工作模式 - l_c_2005的日志 - 网易博客》</li><li>入库时间：2010-12-23</li></ul></div><div id="report_part_12"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">71.11%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">ARM处理器</i><i class="black">复位后只</i><i class="blue">处于ARM状态</i>，<i class="black">可通过相应</i><i class="blue">的指令集在ARM状态和Thumb状态</i><i class="black">下进行切换</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">其中<font color="red">处理器在</font>系统上电时默认为<font color="red">ARM状态</font>。 无论<font color="red">处理器处于</font>何种<font color="red">状态</font>,<font color="red">ARM指令集</font>与<font color="red">Thumb指令集</font>不同同时混合使用。 BX<font color="red">指令可</font>以实现将<font color="red">ARM</font>内核的操作<font color="red">状态在ARM和Thumb</font>之间...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM架构与体系学习(三)——ARM处理器状态 - Sugar的专栏 - 博客...》</li><li>入库时间：2012-04-24</li></ul></div><div id="report_part_13"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">81.36%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">ARM</i><i class="black">有</i><i class="blue">7种</i><i class="black">工作</i><i class="blue">模式</i>，<i class="black">分别是</i><i class="blue">用户 模式</i>、<i class="black">快速</i><i class="blue"> 中断 模式</i>、<i class="black">外部</i><i class="blue"> 中断 模式</i>、<i class="blue">管理 模式</i>、<i class="blue">中止 模式</i>、<i class="blue">未定义 </i><i class="black">指令</i><i class="blue"> 模式和系统 模式</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">处理器上的移植结构：<font color="red">ARM</font>体系结构支持<font color="red">7种</font>处理器<font color="red">模式</font>：<font color="red">用户模式、快中断模式、中断模式、管理模式、中止模式、未定义模式和系统模式</font>。如表1所示：表1<font color="red"> ARM </font>体系结构支持<font color="red">7种</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《嵌入式操作系统μC／OS―Ⅱ在ADuC7020处理器上的移植》</li><li>作者：王雨 李文婷 赵小光</li><li>出处：《华北科技学院学报》 2008，5(1)：90 -93</li><li>机构：中国矿业大学（北京）,北京100083</li></ul></div><div id="report_part_14"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">78.26%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">当工作模式</i><i class="black">为</i><i class="blue">用户模式时</i>，<i class="blue">处理器</i><i class="black">将</i><i class="blue">不能改变当前的工作模式</i>，<i class="blue">除非发生异常</i>，<i class="black">其它</i><i class="blue">的工作模式能</i><i class="black">进行互相切换</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">处理器的</font>各种<font color="red">工作模式</font>由<font color="red">当前</font>程序状态寄存器CPSR的低4位M4:0决定,对应关系如表3...<font color="red">当处理器处</font>于<font color="red">用户模式时</font>,<font color="red">不能改变工作模式</font>,<font color="red">除非发生异常</font>。3.1.2 <font color="red">处理器工作</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《第3章ARM寻址方式与指令系统doc - 其它资料 - 道客巴巴》</li><li>入库时间：2014-03-31</li></ul></div><div id="report_part_15"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">75%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">图</i><i class="black">2-1</i><i class="blue"> ARM处理器</i><i class="black">的</i><i class="blue">工作模式</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">指令集。4.<font color="red">2 ARM处理器工作模式ARM</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《ARM嵌入式系统综述》</li><li>作者：张治国</li><li>出处：《科技资讯》 2007，(21)：107 -108</li><li>机构：枣庄学院网络与现代教育技术中心,山东枣庄,277160</li></ul></div><div id="report_part_16"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">80.36%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">ARM处理器有31个通用寄存器</i>，<i class="blue">6个状态寄存器</i>，<i class="black">总</i><i class="blue">共是37个32位的寄存器</i>，<i class="blue">ARM状态下</i><i class="black">不同工作模式</i><i class="blue">的寄存器</i><i class="black">如</i><i class="black">下图所示</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">情况。2．7 <font color="red">ARM状态下的寄存器</font>组织<font color="red">ARM</font>微<font color="red">处理器共有37个32位寄存器，</font>其中<font color="red">31个</font>为<font color="red">通用寄存器，6个</font>为<font color="red">状态寄存器</font>。但是(下转第<font color="red">23</font>4页) · <font color="red">23</font>0</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《浅析ARM微处理器嵌入式系统的应用》</li><li>作者：黄卫平</li><li>出处：《时代经贸：下旬》 2008，6(7)：230 -230</li><li>机构：杭州亿普科技有限公司,浙江杭州310016</li></ul></div><div id="report_part_17"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">76.09%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">从图</i><i class="black">2-</i><i class="blue">2可</i><i class="black">看出</i>，<i class="blue">ARM处理器在</i><i class="black">不同</i><i class="blue">的工作模式下所使用的寄存器是</i><i class="black">不同</i><i class="black">的</i>。<i class="black">通</i><i class="blue">用寄存器R0</i><i class="black">-</i><i class="blue">R7在所</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">其中<font color="red">R0</font>~<font color="red">R7在所</font>有<font color="red">模式下</font>都可以<font color="red">使用的</font>共有<font color="red">寄存器</font>,R8~R1<font color="red">2是</font>快速中断<font color="red">模式下</font>私有...<font color="red">ARM处理器工作模式</font> <font color="red">ARM处理器模式</font>切换(含<font color="red">MR</font>S,MSR指令) 相关资讯 arm ...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM处理器寄存器_Linux编程_Linux公社-Linux系统门户网站》</li><li>入库时间：2011-09-02</li></ul></div><div id="report_part_18"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">80.43%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">有模式下是共用的</i>，<i class="blue">快速中断模式下有自己</i><i class="black">专</i><i class="blue">用的寄存器R8</i><i class="black">-</i><i class="black">R12</i>，<i class="black">系统</i><i class="blue">模式和用</i><i class="black">户</i><i class="blue">模式下使用</i><i class="black">相</i><i class="blue">同的</i><i class="black">堆</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">在所<font color="red">有的寄存器中有</font>些是各种<font color="red">模式下共用的同</font>一个物理<font color="red">寄存器有</font>些是各种<font color="red">模式自己</font>...例如当<font color="red">使用快速中断模式下的寄存器</font>时<font color="red">寄存器R8和寄存器R</font>9分别记做<font color="red">R8</font>_fiq和 R9...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM处理器模式和寄存器介绍 PDF - 技术总结 - 道客巴巴》</li><li>入库时间：2012-11-24</li></ul></div><div id="report_part_19"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">97.83%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">状态 寄存器</i><i class="black">有</i><i class="blue">1个当前 程序 状态 寄存器 CPSR</i>，<i class="blue">5个 备份 程序 状态 寄存器 SPSR</i>，</p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">位长的<font color="red">寄存器1</font>30个通用<font color="red">寄存器</font>26<font color="red">个状态寄存器1个CPSR当前程序状态寄存器5个SPSR</font>...<font color="red">PCCPSR当前程序状态寄存器SPSR备份程序状态寄存器 </font>N负数Z零C进位V溢出IIRQ使能F...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式2 - 技术总结 - 道客巴巴》</li><li>入库时间：2014-3-17</li></ul></div><div id="report_part_20"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">85.42%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">分别用于5种</i><i class="black">工</i><i class="blue">作模式</i>，<i class="blue">用户模式</i><i class="black">和</i><i class="blue">系统模式没有</i><i class="black">备份</i><i class="blue">程序状态寄存器</i>，<i class="blue">程 序状 态寄 存器的</i><i class="black">格</i><i class="blue">式如</i><i class="black">下</i><i class="black">图所</i><i class="black">示</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">CPSR(当前<font color="red">程序状态寄存器</font>)的低5位<font color="red">用于</font>定义当前操<font color="red">作模式</font>,<font color="red">如图示</font>: 1、<font color="red">用户模式</font>...<font color="red">用户</font>、<font color="red">系统模式没有</font>“保<font color="red">存的程序状态寄存器</font>(SPSR)”,而其他<font color="red">5种模式分别有</font>一个...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM两种工作状态&amp;7种工作模式&amp;37个寄存器_杜金树的空间_百度空间》</li><li>入库时间：2013-12-26</li></ul></div><div id="report_part_21"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">83.61%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">F位为快速中断</i><i class="black">控制</i><i class="black">位</i>，<i class="blue">F为1时</i><i class="black">禁止</i><i class="blue">FIQ中断</i>，<i class="blue">为0时允许快速中断</i>。<i class="blue">I位为中断</i><i class="black">控制</i><i class="black">位</i>，<i class="blue">I为1时允许</i><i class="black">外部</i><i class="blue">IRQ中断</i>，<i class="blue">为0时</i><i class="black">禁止</i><i class="blue">IRQ中断</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">则屏蔽<font color="red">IRQ中断</font>,当I=<font color="red">0时</font>,则<font color="red">允许中断。</font>处理器复位后置<font color="red">I为1</font>,关闭<font color="red">中断。</font>... 7、<font color="red">快速中断</font>(<font color="red">FIQ</font>)请求异常;<font color="red">FIQ快速中断</font>是可屏蔽的。在状态寄存器中的<font color="red">F位</font>就...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM中的异常和中断 来自 chenzhufly的博客-与非网博客》</li><li>入库时间：2009-03-07</li></ul></div><div id="report_part_22"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">70.59%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">2</i>.<i class="black">1</i>.<i class="black">4</i><i class="blue"> ARM处理器的异常处理</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red"> ARM 处理器的异常处理</font>介绍<font color="red">ARM </font>系列<font color="red">处理器</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《》</li><li>作者：王泽民 芦东昕 谢鑫 徐立峰</li><li>出处：《计算机工程》 2005，31(13)：90 -92</li><li>机构：中兴通信股份有限公司成都研究所，成都610041</li></ul></div><div id="report_part_23"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">67.44%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">ARM处理器拥</i><i class="black">有7种</i><i class="blue">不同类型的异常</i>，<i class="black">分别是复位</i>、<i class="blue">未定义 指令</i>、<i class="blue">软件 中断</i>、<i class="blue">指令 预取 中止</i>、<i class="blue">数据</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">软件中断、未定义指令、中断</font>(普通<font color="red">中断</font>和快速<font color="red">中断</font>)<font color="red">、中止</font>(<font color="red">预取中止</font>和<font color="red">数据中止</font>) 等。<font color="red">不同类型异常的</font>进入与返回既有相似性，又明显<font color="red">不同</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《ARM7处理器课程中“异常返回”的教学内容设计》</li><li>作者：张锟</li><li>出处：《电子世界》 2012，(10)：165 -166</li><li>机构：桂林电子科技大学信息科技学院</li></ul></div><div id="report_part_25"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">65%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">7种</i><i class="blue">异常可</i><i class="black">分为</i><i class="blue">6级</i>，<i class="black">其</i><i class="blue">中复位优先级最高</i>，<i class="blue">未定义指令</i><i class="black">和</i><i class="black">软件</i><i class="blue">中断最低</i>，<i class="black">而且这两个</i><i class="blue">异常</i><i class="black">是互斥</i><i class="black">的</i>，<i class="black">不</i><i class="black">可能</i><i class="blue">同时发生</i>，<i class="black">所</i><i class="black">以它们</i><i class="blue">的优先级</i><i class="black">是相</i><i class="blue">同的</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">6 <font color="red">软中断异常</font> <font color="red">最低</font> 7 <font color="red">未定义指令异常</font> <font color="red">异常可以同时发生</font>,此时处理器按表7-2中设置<font color="red">的优先级</font>顺序处理<font color="red">异常</font>。例如,处理器上电<font color="red">时发生复位异常</font>,<font color="red">复位异常的优先级最高</font>,...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《7.3 ARM异常的优先级 - 51CTO.COM》</li><li>入库时间：2012-10-10</li></ul></div><div id="report_part_26"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">73.68%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">当ARM处理器发生异常后</i>，<i class="blue">如果</i><i class="black">是</i><i class="blue">复位异常</i>，<i class="black">会立即中</i><i class="blue">止当前</i><i class="black">运行</i><i class="blue">的指令</i>，<i class="blue">如果</i><i class="black">是其它</i><i class="blue">的异常</i>，<i class="blue">处理器</i><i class="black">会执行</i><i class="blue">完当前指令后</i>，<i class="black">再去</i><i class="blue">处理异常</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">(5)、数据访问终止(DAT<font color="red">AA</font>BORT) <font color="red">如果</font>数据访问<font color="red">指令的</font>目标地址不存在,或者该地址... 除了<font color="red">复位异常</font>外,<font color="red">当异常发生</font>时,<font color="red">ARM处理器</font>尽可能完成<font color="red">当前指令</font>(除了<font color="red">复位异常</font>)后,...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM的异常处理 - liangkaiming的专栏 - 博客频道 - CSDN.NET》</li><li>入库时间：2010-10-21</li></ul></div><div id="report_part_27"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">58.62%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">设置当</i><i class="black">前</i><i class="blue">状态寄存器</i><i class="black">为</i><i class="blue">相应的异常</i><i class="black">工作</i><i class="blue">模式</i>，<i class="black">而且</i><i class="blue">禁止</i><i class="black">I</i><i class="black">RQ外部</i><i class="blue">中断</i>，<i class="black">如果</i><i class="blue">进入的</i><i class="black">是复</i><i class="blue">位模式</i><i class="black">或快速</i><i class="blue">中断模式</i>，<i class="black">还要</i><i class="blue">禁止</i><i class="black">FIQ快速</i><i class="blue">中断</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">到SPSR一<font color="red">寄存器</font>2)<font color="red">设置</font>适<font color="red">当的</font>cPS<font color="red">R位</font>：改变处理<font color="red">器状态进入</font>ARM<font color="red">状态</font>改变处理<font color="red">器模式进入相应的异常模式设置中断禁止位禁止相应中断</font>／／保<font color="red">存异常中断</font>返回地址</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《中断向量表在ARM异常中断中的应用》</li><li>作者：刘维梁 任长明</li><li>出处：《微处理机》 2008，29(4)：116 -119</li><li>机构：天津大学电子信息工程学院,天津300072</li></ul></div><div id="report_part_28"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">84.62%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">把</i><i class="blue">异常指令的下一条地址保存到异常模式下的</i><i class="black">寄</i><i class="blue">存器R14中</i>，<i class="black">当</i><i class="blue">异常处理完后</i>，<i class="blue">程序</i><i class="black">才</i><i class="blue">能返回原</i><i class="black">来</i><i class="blue">的指令处</i><i class="black">继续向</i><i class="blue">下执行</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">异常指令的下一条指令的地址保存到</font>新<font color="red">的异常</font>工作<font color="red">模式的R14</font> 即<font color="red">R14</font>_mode<font color="red">中，</font>使<font color="red">异常处理程序执行完后能</font>正确<font color="red">返回原程序</font>。给<font color="red">程序</font>计数器强制赋值</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《基于ARM7TDMI内核的S3C4480异常处理分析》</li><li>作者：季振华</li><li>出处：《微计算机信息》 2006，()：137 -139</li><li>机构：义乌工商学院</li></ul></div><div id="report_part_29"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.33%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">清除</i><i class="black">CPS</i><i class="blue">R中的中断</i><i class="black">屏蔽位</i>，<i class="black">打开</i><i class="blue">IRQ</i><i class="black">外部</i><i class="blue">中断和FIQ快速中断</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">中断IRQ和快速中断FIQ，FIQ的</font>优先级要高于<font color="red">IRQ</font>。$3C4510一共有21个</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《ARM7嵌入式系统的中断设计与中断处理优化》</li><li>作者：刘岚 张凯</li><li>出处：《武汉理工大学学报》 2004，26(4)：88 -90</li><li>机构：武汉理工大学信息工程学院，武汉430070</li></ul></div><div id="report_part_30"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">66.67%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">本论文所写</i><i class="black">的嵌入式操作系统是</i><i class="blue">在飞凌公司的</i><i class="black">OK</i><i class="blue">6410开发板</i><i class="black">下所完成</i><i class="black">的</i>，<i class="black">OK</i><i class="blue">6410开发板</i><i class="black">是</i><i class="blue">基于三星公司的ARM11处理器S3C6410</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">了<font color="red">飞凌的</font>ok<font color="red">6410</font> <font color="red">开发板</font>。ok<font color="red">6410</font> <font color="red">开发板基于三星公司</font>最新<font color="red">的ARM11</font> <font color="red">处理器S3C6410，</font>拥有强大的内部资源和视频<font color="red">处理</font>能力，可稳定运行<font color="red">在66</font>7MHz 主频以上，支持</p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《基于ANDROID平台的11N无线网络终端的研究与实现》</li><li>作者：唐伟</li><li>专业：软件工程</li><li>年份：2010</li><li>机构：苏州大学</li></ul></div><div id="report_part_31"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">88.16%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">S3C6410</i><i class="black">采</i><i class="blue">用64</i><i class="black">/</i><i class="blue">32</i><i class="black">位</i><i class="blue">的内部总线架构</i>，<i class="blue">为2</i>.<i class="blue">5G和3G通信服务提供了优化的H</i><i class="black">/W</i><i class="blue">性能</i>，<i class="black">该</i><i class="blue">64</i><i class="black">/</i><i class="blue">32</i><i class="black">位</i><i class="blue">的内部总线架构</i><i class="black">是由</i><i class="blue">AXI</i>、<i class="blue">AHB和APB总线</i><i class="black">组成</i><i class="black">的</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">6410</font> 硬件使用手册 <font color="red">S3C6410</font> 开发板 (<font color="red">AP</font>DK<font color="red">6410</font>) <font color="red">...为</font> <font color="red">2.5G</font> 和 <font color="red">3G</font> <font color="red">通信服务提供了优化的</font>硬件<font color="red">性能</font>,<font color="red">...32</font>bit <font color="red">的内部总线架构</font>,融合了 <font color="red">AXI、AHB、APB</font> <font color="red">总线...</font></p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《S3C6410 开发板(APDK6410)硬件使用手册》</li><li>入库时间：2013-04-17</li></ul></div><div id="report_part_32"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">80.49%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">它</i><i class="blue">还有很多强大的硬件加速器</i>，<i class="black">比如</i><i class="blue">2D</i><i class="black">图像</i><i class="blue">处理</i>、<i class="black">图形</i><i class="blue">显示和缩放处理</i>、<i class="blue">运动视频处理</i>、<i class="blue">音频处理</i><i class="black">等</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">还有很多强大的硬件加速器</font>, 包括<font color="red">运动视频处理、音频处理、2D</font> <font color="red">加速、显示处理和缩放</font>。 1.2 电容式多点触摸屏 电容式触摸屏在触摸屏 4 边均镀上狭长的电极,在...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《基于I2C的嵌入式触摸屏驱动设计_百度文库》</li><li>入库时间：2011-11-25</li></ul></div><div id="report_part_33"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">90.32%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">一个集成的</i><i class="black">多格</i><i class="blue">式编解码器</i>（<i class="black">Multi</i><i class="blue"> F</i><i class="black">ormat</i><i class="blue"> C</i><i class="black">odec</i>，<i class="blue">MFC</i>）<i class="blue">和MPEG4/H</i>.<i class="blue">263/H</i>.<i class="blue">264编解码器和VC1解码器</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">一个集成的MFC</font>(MULTI-FORMAT<font color="red"> V</font>IDEO<font color="red"> C</font>OD<font color="red">EC</font>)支持<font color="red">MPEG4 /H.263/H.264编解码和VC1的解码</font>,这个硬件<font color="red">编解码器</font>支持实时的视频会议以及NRS<font color="red">C和P</font>AL制<font color="red">式的</font>TV输出。内置<font color="red">一个...</font></p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《S3C6410开发板 – 成都明程科技有限公司,嵌入式行业解决方案提供...》</li><li>入库时间：2010-07-29</li></ul></div><div id="report_part_34"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">68%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">这种H/W</i><i class="blue">编解码器</i><i class="black">能</i><i class="blue">支持实时视频会议和电视输出的NTSC和PAL</i><i class="black">两种模</i><i class="black">式</i>。<i class="black">此外</i>，<i class="black">该</i><i class="blue">处理器</i><i class="black">含</i><i class="black">有一</i><i class="blue">个3</i><i class="black">D加速</i><i class="black">器</i>，<i class="blue">支持</i><i class="black">OpenG</i><i class="blue">L </i><i class="black">E</i><i class="blue">S 1</i>.<i class="black">1/2</i>.<i class="blue">0的</i><i class="black">图形渲染</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">的编解码</font>,<font color="red"> 这个</font>硬件<font color="red">编 解码器支持实时视频会议和电视输出</font>(<font color="red">NTSC 和 PAL </font>制式)<font color="red">...</font>[6] 侯殿<font color="red">有 </font>, 刘晓光 , 吉鹤<font color="red"> .S3C</font>64<font color="red">10</font>X(ARM<font color="red">11</font>) 精简指令系统微<font color="red">处理</font>机 (<font color="red">...</font></p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《基于WinCE6_0的物联网系统架构设计与实现_百度文库》</li><li>入库时间：2011-08-18</li></ul></div><div id="report_part_35"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">69.81%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">S3C6410具有一个优化的接口连接到外部存储器</i>。<i class="black">这种</i><i class="blue">优化的接口</i>，<i class="blue">外部存储器</i><i class="black">是能在</i><i class="black">高速通信服务上维持</i><i class="black">高内</i><i class="black">存带宽</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">S3C6410</font> <font color="red">有一个优化的接口连</font>线<font color="red">到外部存储器。存储器</font>系统<font color="red">具有</font>双重<font color="red">外部存储器</font>端口...(3) <font color="red">一个</font>8 位ITU <font color="red">601</font>/656 相机<font color="red">接口</font>,用于缩放<font color="red">的高</font>达4M 像素,固定<font color="red">的16</font>M ...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《S3C6410芯片揭密之一 S3C6410体系结构-yjvijfhvk-ChinaUnix博客》</li><li>入库时间：2011-09-22</li></ul></div><div id="report_part_36"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">84.21%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">内</i><i class="blue">存系统具有双重外部存储器端口</i>，<i class="blue">DRAM和F</i><i class="black">lash</i><i class="blue">/ROM</i>。<i class="black">在</i><i class="blue">DRAM端口可以配置为支持</i><i class="black">mobile</i><i class="blue"> DDR</i>、<i class="blue">DDR</i>、<i class="black">mobile</i><i class="blue"> SDRAM和SDRAM</i><i class="black">内</i><i class="black">存</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">S3C6410有一个优化的接口连线到<font color="red">外部存储器。存储器系统具有双重外部存储器端口、DRAM和F</font>L<font color="red">AS</font>H<font color="red">/ROM/DRAM端口。DRAM</font>的<font color="red">端口可以配置为支持</font>移动<font color="red"> DDR</font>,<font color="red">DDR</font>,移动<font color="red"> SDRAM和</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《14.物联网应用技术实训系统实训教程(智能家居).doc-文档投稿赚钱网》</li><li>入库时间：2013-07-15</li></ul></div><div id="report_part_37"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">84.44%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">为了降低</i><i class="blue">系统的总体成本和提高整体功能</i>，<i class="blue">S3C6410包</i><i class="black">含了</i><i class="blue">许多硬件外设</i>，<i class="black">例</i><i class="blue">如相机接口</i>、<i class="blue">TFT </i><i class="black">2</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">第<font color="red"> 3 </font>章,嵌入式媒体播放器<font color="red">总体设</font>计。对嵌入式媒体播放器<font color="red">的体系</font>结构和模块结构,...为减少<font color="red">系统总成本和提高整体功能</font>,<font color="red">S3C6410 包</font>括<font color="red">许多硬件外设</font>,如一个<font color="red">相机接口</font>,<font color="red">TFT</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式报告(大头聪) - 电子设计 - 道客巴巴》</li><li>入库时间：2012-05-11</li></ul></div><div id="report_part_38"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">76.19%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">4位真彩色</i><i class="blue">LCD控制器</i>、<i class="blue">系统管理器</i>（<i class="blue">电源管理等</i>）、<i class="black">4个的</i><i class="blue">UART</i>、<i class="blue">32</i><i class="black">个</i><i class="blue">DMA</i>、<i class="black">5个</i><i class="blue">32</i><i class="black">位</i><i class="blue">定时器</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">液晶显示<font color="red">控制器</font>,<font color="red">系统管理器</font>(<font color="red">电源管理等</font>),4 通道<font color="red">UART</font>,<font color="red">32</font> 通道<font color="red">DMA</font>,4 通道<font color="red">定时</font>... 4.显示<font color="red">控制</font>显示<font color="red">控制</font>特性包括:(1)TFT <font color="red">LCD</font> 接口 <font color="red">32</font>0×<font color="red">24</font>0,640×480 或其他...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《s3c6410芯片揭密之一s3c6410体系结构s3c6410是一个16/32位risc微处》</li><li>入库时间：2011-09-22</li></ul></div><div id="report_part_39"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">100%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">设备</i>、<i class="blue">USB OTG设备高速传输</i>（<i class="blue">480Mbps</i>）、<i class="blue">3通道SD/MMC主机控制器和PLL时钟发生器</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">/ O </font>端口、I2<font color="red">S </font>接口、总线接口、I2<font color="red">C </font>总线接口<font color="red">、 USB 主机、高速USB </font>接口<font color="red">OTG 设备</font>(<font color="red">480Mbps </font>的<font color="red">传输速</font>度)<font color="red">、3 通道SD / MMC </font>记忆<font color="red">主机控制器和</font>的<font color="red">PLL 时钟发生器</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《UP-CUP2440实验指导书(LINUX)V2.0 20110818 - 豆丁网》</li><li>入库时间：2011-08-18</li></ul></div><div id="report_part_40"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">88.57%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">S3C6410的ARM</i><i class="black">子系统是</i><i class="blue">基于ARM1176JZF-S内核</i>。<i class="black">它</i><i class="blue">包括</i><i class="black">独</i><i class="blue">立的16KB指令和16KB的数据</i><i class="black">缓存</i>、<i class="blue">16KB指令和16KB的数据TCM</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"> 图3.2 <font color="red">S3C6410</font> 结构框图<font color="red">S3C6410</font> <font color="red">基于ARM1176JZF-S</font> <font color="red">内核。包括</font>分<font color="red">立的16KB</font> <font color="red">指令和16KB</font> <font color="red">数据C</font>ache，<font color="red">16KB</font> <font color="red">指令和数据TCM。</font>还<font color="red">包括</font>一个完全<font color="red">的MM</font>U</p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《基于ARM11的井下多媒体数据处理终端》</li><li>作者：罗文静</li><li>专业：信号与信息处理</li><li>年份：2010</li><li>机构：西安科技大学;西安科技大学</li></ul></div><div id="report_part_41"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">84.21%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">S3C6410采用</i><i class="black">实际</i><i class="blue">标准的AMBA总线</i><i class="black">架</i><i class="black">构</i>。<i class="black">这种</i><i class="blue">强大的</i>、<i class="black">行</i><i class="blue">业标准的特</i><i class="black">点让</i><i class="blue">S3C6410</i><i class="black">能够</i><i class="blue">支持许多工业标准的操作系统</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"> 图形应<font color="red">用。S3C6410</font> <font color="red">采用</font>de-facto <font color="red">标准AMBA</font> <font color="red">总线</font>结<font color="red">构。这</font>些<font color="red">强大的工业</font>级特性使<font color="red">S3C6410</font> 可以<font color="red">支持许多工业标准的操作系统。</font>此外，三星公司</p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《基于ARM11的井下多媒体数据处理终端》</li><li>作者：罗文静</li><li>专业：信号与信息处理</li><li>年份：2010</li><li>机构：西安科技大学;西安科技大学</li></ul></div><div id="report_part_42"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">94.81%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">OK6410开发板</i><i class="black">采用</i><i class="blue">S3C6410</i><i class="black">芯片</i>，<i class="blue">拥有强大的内部资源和视频处理能力</i>，<i class="blue">可以稳定运行在667MHz主频上</i>，<i class="blue">支持Mobile DDR和多种NAND Flash</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">OK6410开发板</font>基于三星公司最新<font color="red">的ARM11处理</font>器<font color="red">S3C6410</font>,<font color="red">拥有强大的内部资源和视频处理能力</font>,<font color="red">可稳定运行在667MHz主频以上</font>,<font color="red">支持Mobile DDR和多种NAND Flash</font>。<font color="red">OK6410开发板</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《飞凌OK6410-A开发板硬件手册V2.1 - 豆丁网》</li><li>入库时间：2014-01-23</li></ul></div><div id="report_part_43"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">91.53%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">OK</i><i class="blue">6410开发板上集成了多种高端接口</i>，<i class="blue">如液晶屏</i>、<i class="blue">以太网</i>、<i class="blue">复合视频信号</i>、<i class="blue">摄像头</i>、<i class="blue">SD卡</i>、<i class="blue">USB等</i>，<i class="blue">并配备红外接收头</i>、<i class="blue">温度传感器等</i><i class="black">[5]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">Mobile <font color="red">DD</font>R 和<font color="red">多种</font>NAND Flash。ok<font color="red">6410</font> <font color="red">开发板上集成了多种高端接口，如复合视频信号、摄像头、USB、SD</font> <font color="red">卡、液晶屏、以太网，并配备温度传感器</font>和<font color="red">红外接收头等</font></p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《基于ANDROID平台的11N无线网络终端的研究与实现》</li><li>作者：唐伟</li><li>专业：软件工程</li><li>年份：2010</li><li>机构：苏州大学</li></ul></div><div id="report_part_44"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">93.18%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">为</i><i class="blue">533MHz/667MHz</i>，<i class="black">总</i><i class="black">共有</i><i class="blue">4个串口</i>，<i class="blue">包括1个五线RS-232电平串口</i>（<i class="blue">DB9母座</i>）<i class="blue">和3</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">Samsung <font color="red">S3</font>C<font color="red">641</font>0处理器,A<font color="red">RM1176</font>JZF<font color="red">-S</font>内核,主频<font color="red">533MHz/667MHz</font> 长宽尺寸仅5CM*... <font color="red">共4个串口</font>,<font color="red">包括1个五线RS</font> <font color="red">232电平串口</font>(<font color="red">DB9母座</font>)<font color="red">和3个</font>三线TTL<font color="red">电平串口</font>(20...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《6410开发板-飞凌嵌入式技术有限公司》</li><li>入库时间：2014-1-13</li></ul></div><div id="report_part_45"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">68.18%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">经分析</i>，<i class="blue">本嵌入式操作系统</i><i class="black">需要</i><i class="blue">实现</i><i class="black">以下</i><i class="blue">的基本功能</i><i class="black">：</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">嵌入式操作系统的基本功能</font>。“优”，在特定领域<font color="red">实现</font>最优化性能指标</p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《嵌入式操作系统ASOS的研究》</li><li>作者：朱立新</li><li>专业：控制工程与控制理论</li><li>年份：2004</li><li>机构：中国科学院自动化研究所</li></ul></div><div id="report_part_46"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">61.7%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">引导启动</i><i class="blue">模块是</i><i class="black">整</i><i class="blue">个嵌入式系统的</i><i class="black">首</i><i class="blue">要模块</i>，<i class="black">主</i><i class="black">要功能</i><i class="blue">就是</i><i class="black">引导并启动</i><i class="blue">操作系统</i>，<i class="black">跟b</i><i class="blue">ootloader</i><i class="black">类似</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">的就是</font>基于ARM<font color="red">嵌入式系统</font>通用B<font color="red">ootloader的</font>设计与实现。B<font color="red">ootloader是嵌入式系统</font>中执行在内核<font color="red">操作系统</font>前的一个重<font color="red">要模块</font></p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《基于嵌入式arm的bootloader研究与实现 》</li><li>作者：丁岩军</li><li>专业：计算机应用技术</li><li>年份：2007</li><li>机构：华北电力大学(北京)</li></ul></div><div id="report_part_47"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.04%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">的地址处</i><i class="black">开始</i><i class="blue">执行程序</i>，<i class="blue">因此</i><i class="black">我们</i><i class="blue">需要在</i><i class="black">0x00000000</i><i class="blue">处设置一条跳转指令</i>，<i class="blue">跳转到程序的</i><i class="black">初始化</i><i class="black">处</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">在进入异常中断处理<font color="red">程序</font>时,要保存被中断<font color="red">程序的执行</font>...b、通过<font color="red">设置</font>PC<font color="red">跳转到</font>复位中断向量<font color="red">处执行</font>称为软复位...<font color="red">因此</font>,<font color="red">需要在</font>各入口<font color="red">地址处</font>放<font color="red">一条跳转指令</font>,<font color="red">跳转到</font>相应...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM 的异常处理 - 陈さん様 - 博客园》</li><li>入库时间：2012-12-21</li></ul></div><div id="report_part_48"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">66%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">不同</i><i class="blue">的N</i><i class="black">A</i><i class="black">ND</i><i class="blue"> Flash</i><i class="black">其</i><i class="blue">读写的数据方式</i><i class="black">也不同</i>，<i class="black">因此</i><i class="blue">需要根据N</i><i class="black">A</i><i class="black">ND</i><i class="blue"> Flash的</i><i class="black">芯片手册</i><i class="blue">来进行</i><i class="black">编</i><i class="black">写</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">I／O口的控制<font color="red">方式进行数据</font>存取，这就要求<font color="red">Na</font>nd<font color="red"> Flash的读写</font>操作都要由驱动程序来控制。要正确驱动<font color="red">Na</font>nd<font color="red"> Flash，</font>首先<font color="red">需要根据</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《基于MTD系统实现Nand Flash的设备驱动》</li><li>作者：吴振英[1] 俞鑫东[2]</li><li>出处：《苏州大学学报：工科版》 2012，32(4)：12 -17</li><li>机构：[1]苏州工业职业技术学院电子系,江苏苏州215104 [2]金龙联合汽车工业（苏州）有限公司,江苏苏州215021</li></ul></div><div id="report_part_49"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.64%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">每个任务都</i><i class="black">属于</i><i class="blue">整个应用的某一部分</i>，<i class="blue">都被赋予一定的优先级</i>，<i class="blue">有自己</i><i class="black">独立</i><i class="black">的栈空间</i>，<i class="black">彼此独立运行[6]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">的设计过程，包括如何把问题分割成多<font color="red">个任务，每个任务都</font>是<font color="red">整个应用的某一部分，每个任务被赋予一定的优先级，有</font>它<font color="red">自己的一</font>套CPU</p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《μc/os-Ⅱ中解决优先级反转问题的设计模式及实现方法研究 》</li><li>作者：郭洋</li><li>专业：计算机应用技术</li><li>年份：2006</li><li>机构：沈阳工业大学</li></ul></div><div id="report_part_50"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">65.91%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">它</i><i class="blue">任务</i><i class="black">可以</i><i class="blue">运行时</i>，<i class="blue">空闲任务</i><i class="black">就会</i><i class="blue">运行</i>，<i class="black">这样</i><i class="blue">CPU</i><i class="black">就</i><i class="black">不会没事可做</i><i class="black">了</i>，<i class="blue">统计任务用</i><i class="black">于</i><i class="blue">统计CPU的利用</i><i class="black">率</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">不是更好,省掉了“<font color="red">空闲任务</font>”,且能充分<font color="red">利用</font>主函数... <font color="red">CPU</font>总要有东西在<font color="red">运行的</font>,<font color="red">任务空闲时</font>,<font color="red">运行空闲任务</font>...至少<font color="red">统计任务</font>是无法完成,<font color="red">CPU</font>测速函数无法实现... 回复...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《OS空闲为什么一定要运行空闲任务?个人认为空闲运行主函数更好。 (...》</li><li>入库时间：2010-02-25</li></ul></div><div id="report_part_51"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">62.86%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">制块创建完后</i>，<i class="blue">任务就</i><i class="black">进</i><i class="blue">入就绪态</i><i class="black">了</i>，<i class="blue">当任务</i><i class="black">得到</i><i class="blue">CPU</i><i class="black">而</i><i class="blue">运行</i><i class="black">后</i>，<i class="blue">处于运行态</i>，<i class="blue">当任务</i><i class="black">进</i><i class="black">入休眠后</i>，<i class="blue">就处于</i><i class="black">休眠</i><i class="black">态</i>，<i class="blue">当任务</i><i class="black">被</i><i class="blue">挂起</i><i class="black">后</i><i class="black">就进</i><i class="blue">入等待态</i>，<i class="black">被中断</i><i class="blue">的任务处于</i><i class="black">中断</i><i class="black">态</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">占用<font color="red">CPU的</font>使用权时，该<font color="red">任务处于运行态</font>。<font color="red">处于运行态任务的</font>优先权一定高于其它所有<font color="red">就绪态任务的</font>优先权。当系统<font color="red">运行</font>致使某一<font color="red">就绪态任务</font>优先权高<font color="red">于运行态任务的</font>优先权时，调用调度函数<font color="red">，运行态任务</font>将转<font color="red">入挂起态等待</font>某一</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《嵌入式操作系统在定量加液控制仪的研制与应用》</li><li>作者：祁伟[1] 吴涓[2]</li><li>出处：《有色设备》 2006，(4)：7 -9</li><li>机构：[1]广东技术师范学院自动化系,广东广州510630 [2]广州市国际工程咨询公司项目二部,广东广州510660</li></ul></div><div id="report_part_52"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">86.49%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">嵌入式操作系统的调度算法可分为优先级法和时间片轮转法</i>，<i class="blue">优先级法又可分为非抢占式优先级法和抢占式优先级法</i>，<i class="blue">时间片轮转法</i><i class="black">也</i><i class="blue">可分为时间</i><i class="black">固定与</i><i class="black">可变</i><i class="black">两种方</i><i class="black">式[8]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">该<font color="red">算法</font>涉及到高<font color="red">优先级调度算法</font>、<font color="red">时间片轮转算法</font>、...,可从手机<font color="red">的嵌入式系统</font>到超级电脑的大型<font color="red">操作系统</font>。...STCF<font color="red">又分为两</font>类:<font color="red">非抢占式和抢占式</font>。<font color="red">非抢占式</font>STCF...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《操作系统课程设计报告-基于时间片的高优先级调度模拟实现.doc-...》</li><li>入库时间：2013-05-17</li></ul></div><div id="report_part_53"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">60.42%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">对</i><i class="blue">于大多数的嵌入式实时操作系统</i>，<i class="black">为了使</i><i class="blue">系统能够快速响应外部</i><i class="black">突发</i><i class="blue">事件</i>，<i class="black">一般都采</i><i class="black">用基</i><i class="black">于优先级</i><i class="black">的算法[6]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">4)安全性安全性是反映<font color="red">嵌入式实时操作系统能够</font>抵御...<font color="red">实时</font>性是反映<font color="red">嵌入式实时操作系统快速响应外部事件的</font>...由<font color="red">于大多数嵌统</font>调<font color="red">用时</font>间、上下文切换时间、任务切换...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式实时操作系统性能测试方法 - 期刊论文 - 道客巴巴》</li><li>入库时间：2014-01-25</li></ul></div><div id="report_part_54"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">68.29%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">因此</i>，<i class="black">为了确保</i><i class="blue">系统的实时性</i>，<i class="blue">本课题</i><i class="black">所设计</i><i class="blue">的嵌入式操作系统采用</i><i class="black">了按</i><i class="blue">优先级的抢占式调度</i><i class="black">机制</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">本课题实</font>现<font color="red">的实时操作系统</font>内核--AcoolOS,它支持多...<font color="red">采用</font>基于<font color="red">优先级的</font>可 <font color="red">抢占式调度</font>,对相同<font color="red">优先级的</font>任务...<font color="red">采用的操作系统</font>支持<font color="red">实时性</font>,即<font color="red">嵌入式实时操</font> <font color="red">作系统</font>。...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《[DOCIN]嵌入式实时操作系统内核ACOO1OS的设计与实现 - 豆丁网》</li><li>入库时间：2012-08-18</li></ul></div><div id="report_part_55"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">86.67%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">采用</i><i class="black">按</i><i class="blue">优先级的抢占式调度策略</i>，<i class="blue">系统总能优先运行最高优先级的就绪任务</i>。<i class="blue">当一个任务</i><i class="black">在</i><i class="blue">运行</i><i class="black">期间</i>，<i class="black">使</i><i class="black">得另</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">相应地,μC/OS2Ⅱ内核<font color="red">采用的</font>是基于<font color="red">优先级的抢占式调度策略。系统</font>为每<font color="red">个任务</font>分配<font color="red">一个优先级</font>,<font color="red">最高优先级的任务一</font>旦<font color="red">就绪</font>,<font color="red">总能得</font>到CPU的控制权<font color="red">。当一个运行</font>着<font color="red">的任务</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《μC/OS2Ⅱ中优先级调度算法的改进及实现-嵌入式-电子工程世界网》</li><li>入库时间：2012-04-06</li></ul></div><div id="report_part_56"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">85.11%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">外</i><i class="blue">一个更高优先级的任务进入</i><i class="black">了</i><i class="blue">就绪状态</i>，<i class="black">那么</i><i class="blue">当前</i><i class="black">正在</i><i class="blue">运行的任务的CPU使用权就</i><i class="black">会</i><i class="blue">被更高优先级的就绪</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">UC</font>OS中提供各种函数<font color="red">使任务</font>能从<font color="red">一个状态</font>变为另<font color="red">一个状态</font> 每<font color="red">个任务</font>都有自己<font color="red">的CPU</font>...<font color="red">当运行的任务使一个更高优先级的任务进入就绪态</font>,<font color="red">当前任务的CPU使用权就被</font>剥夺...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《UCOS-II移植ARM的读书笔记(12.17) - 永远的BATIGOAL - 博客频道 -...》</li><li>入库时间：2006-12-17</li></ul></div><div id="report_part_57"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">77.27%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">任务</i><i class="black">所占用</i>，<i class="blue">如果是中断服务使一个更高优先级的任务进入了就绪</i><i class="black">状</i><i class="black">态</i>，<i class="black">那么当</i><i class="blue">中断</i><i class="black">完</i><i class="black">成后</i>，<i class="black">并不会继续</i><i class="blue">运行被中断的任务</i>，<i class="blue">而是</i><i class="black">去</i><i class="blue">运行更高优先级的就绪任务</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">，由于<font color="red">中断服务</font>子程序ISR的执<font color="red">行，是</font>否使得<font color="red">一个优先级更高的任务进入了就绪态</font>。<font color="red">如果是，</font>则要让这<font color="red">个优先级更高的任务</font>开始<font color="red">运行</font>。在这种情况下<font color="red">，被中断了的任务</font>只有重新成为<font color="red">优先级</font>最<font color="red">高的任务而进入就绪</font></p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《ASIXOS嵌入式实时操作系统关键技术研究及实现》</li><li>作者：陈俊</li><li>专业：软件工程(IC)</li><li>年份：2006</li><li>机构：东南大学</li></ul></div><div id="report_part_58"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.64%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">子程序</i><i class="black">ISR</i>，<i class="blue">中断服务子程序</i><i class="black">ISR同</i><i class="blue">时使一个更高优先级的任务进入就绪</i><i class="black">状</i><i class="black">态</i>，<i class="black">当</i><i class="blue">中断服务程序执行</i><i class="black">完后</i>，<i class="black">调度器</i><i class="black">会选择</i><i class="blue">更高优先级的就绪任务</i><i class="black">来运</i><i class="black">行</i>，<i class="black">而不是恢复</i><i class="blue">被中断了的任务</i><i class="black">继续运</i><i class="black">行[9][10]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">而进入中断服务程序中，</font>响应<font color="red">中断时，</font>正在<font color="red">执行的程序被</font>挂起<font color="red">，中断服务子程序</font>控制CPU使用权。<font color="red">中断服务子程序</font>可能会报告<font color="red">一个</font>或多个事件的发生<font color="red">，而使一个</font>或多<font color="red">个任务进入就绪态</font>。如果<font color="red">中断服务子程序使一个优先级更高的任务进入了就绪态，</font>则新<font color="red">进入就绪态的</font>这个</p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《基于dsp的嵌入式实时操作系统研究 》</li><li>作者：康玉东</li><li>专业：通信与信息系统</li><li>年份：2004</li><li>机构：西北工业大学</li></ul></div><div id="report_part_59"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">59.18%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">这里</i><i class="blue">优先级</i><i class="black">号采用整数来表示</i>，<i class="black">0为</i><i class="blue">最高优先级</i>，<i class="black">数字越小</i>，<i class="blue">优先级</i><i class="black">越</i><i class="black">高</i>，<i class="blue">高优先级的任务先</i><i class="black">运</i><i class="black">行</i>，<i class="blue">低优先级的任务</i><i class="black">后运</i><i class="black">行</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">该项资源从而导致具有<font color="red">最高优先级的任务</font>被<font color="red">低优先级任务</font>阻塞可能会使具有中<font color="red">优先级的任务先</font>于<font color="red">高优先级的任务</font>执行[1~3] 1 <font color="red">最高优先级</font>就绪<font color="red">任务的</font>调度</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《嵌入式RTOS中任务调度问题研究》</li><li>作者：冀常鹏 刘建辉 包剑</li><li>出处：《辽宁工程技术大学学报：自然科学版》 2004，()：159 -161</li><li>机构：辽宁工程技术大学,电子与信息工程系,辽宁,阜新,123000 辽宁工程技术大学,电子与信息工程系,辽宁,阜新,123000 辽宁工程技术大学,电子与信息工程系,辽宁,阜新,123000</li></ul></div><div id="report_part_60"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.83%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei">，<i class="black">称为</i><i class="blue">空任务块控制链表</i>，<i class="black">当需要</i><i class="blue">创建任务时</i>，<i class="black">便可</i><i class="blue">从这个链表中</i><i class="black">拿出</i><i class="blue">一个空</i><i class="black">的</i><i class="blue">任务控制块</i>，<i class="black">来设置</i><i class="blue">任务</i><i class="black">的相关信息</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">每<font color="red">当创建一个</font>新<font color="red">任务时</font>,就<font color="red">从这个链表</font>取<font color="red">一个空任务控制块</font>,同时移动OSTCBFreeList 变量,使之指向下<font color="red">一个空任务控制块</font>,然后填充<font color="red">任务</font>属性后,再插入到<font color="red">任务控制链表中</font>(注...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《uc-os内核数据结构 - 豆丁网》</li><li>入库时间：2013-05-14</li></ul></div><div id="report_part_61"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">75%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">其中</i><i class="blue">分区</i><i class="black">的</i><i class="blue">管理算法简单</i>，<i class="blue">易于实现</i>，<i class="black">但</i><i class="blue">碎片问题严重</i>，<i class="blue">内存利用率低</i><i class="black">[11]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">分区管理</font>技术   分页技术   分段技术   虚拟存储...程序设计,所需硬件支持很少,<font color="red">管理算法简单</font>,<font color="red">易于实现</font>。...▲主要缺点:<font color="red">碎片问题严重</font>,<font color="red">内存利用率低</font>,不<font color="red">利于</font>大...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《第四章 - 存储管理 - 豆丁网》</li><li>入库时间：2012-06-13</li></ul></div><div id="report_part_62"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">69.57%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">本系统采用比较简单</i><i class="blue">的固定分区法</i><i class="black">来实现</i><i class="blue">内存的</i><i class="black">管理</i>。<i class="blue">固定分区法就是内存中分区的个数固定不变</i>，<i class="blue">各个分区</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">分区法就是内存中分区的个数固定不变，各个分区的</font>大小<font color="red">固定不变。</font>根据大小<font color="red">的不</font>同，还可以分为等分方式和<font color="red">分区</font>差分方式。所谓等分方式</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《》</li><li>作者：赵奎 张帆</li><li>出处：《企业技术开发》 2005，24(1)：23 -25</li><li>机构：湖南大学电气与信息工程院，湖南长沙410082</li></ul></div><div id="report_part_63"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">91.53%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">的大小固定不变</i>，<i class="blue">根据大小的不同还可分为等分方式和差分方式</i>，<i class="blue">所谓等分</i>，<i class="blue">就是各个分区大小</i><i class="black">相</i><i class="black">同</i>，<i class="blue">所谓差分</i>，<i class="blue">就是分区</i><i class="black">具有</i><i class="blue">不同大小</i><i class="black">[</i><i class="blue">12</i><i class="black">]</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">法<font color="red">和可变分区</font>法两种常见<font color="red">的分</font>配方法。2．<font color="red">1固定分区</font>法<font color="red">固定分区</font>法<font color="red">就是</font>内存中<font color="red">分区的个</font>数<font color="red">固定不变，各个分区的大小固定不变</font>。<font color="red">根据大小的不同，还可</font>以<font color="red">分为等分方式和分区差分方式</font>。<font color="red">所谓</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《》</li><li>作者：赵奎 张帆</li><li>出处：《企业技术开发》 2005，24(1)：23 -25</li><li>机构：湖南大学电气与信息工程院，湖南长沙410082</li></ul></div><div id="report_part_64"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">65.88%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">有了</i><i class="blue">内存分区后</i>，<i class="black">我们还</i><i class="blue">需要一个内存控制块来管理内存分区</i><i class="black">里</i><i class="blue">的内存块</i>，<i class="black">实现</i><i class="blue">真正的内存分</i><i class="black">配</i>。<i class="blue">内存控制块需要</i><i class="black">设置</i><i class="blue">内存分区的</i><i class="black">起始地址</i>、<i class="blue">内存块的</i><i class="black">大小</i>、<i class="blue">内存块的</i><i class="black">数量</i>，<i class="black">已经</i><i class="black">分配出去</i><i class="blue">的内存块</i><i class="black">数量等信息</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">使用情况通过<font color="red">内存控制</font> <font color="red">内存分区</font>中<font color="red">的内存块</font>使用情况...<font color="red">控制块</font>连接以后才构成<font color="red">真正</font> <font color="red">的内存分区</font>,进行动态<font color="red">内存</font>...每<font color="red">一个内存分区需要一个内存控制块来管理</font>, 每<font color="red">一个</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《第7章 内存的动态分配_百度文库》</li><li>入库时间：2010-12-14</li></ul></div><div id="report_part_65"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">63.46%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">因此</i>，<i class="blue">需要在主机</i>（<i class="blue">PC机</i>）<i class="black">上先为</i><i class="blue">开发板</i><i class="black">搭</i><i class="blue">建对应的开发环境</i>，<i class="black">然后</i><i class="blue">编译</i><i class="black">出</i><i class="blue">对应的应</i><i class="black">用</i><i class="blue">程序</i>，<i class="black">最后烧写到</i><i class="blue">开发板上</i>，<i class="black">才能正常运</i><i class="black">行</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">交叉<font color="red">编译</font>调试<font color="red">环境建</font>立在宿<font color="red">主机</font>(即一台 <font color="red">PC</font> 机)上,<font color="red">对应的开发板</font>叫做目标板。 ...<font color="red">开发的程序</font>进<font color="red">行编译</font>链接,所以我们<font color="red">需要</font>一种特殊<font color="red">的编译</font>工具进<font color="red">行在PC机上</font>进<font color="red">行编译</font>,...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式3D-嵌入式3D开发环境的建立- 建立宿主主机开发环境》</li><li>入库时间：2007-05-17</li></ul></div><div id="report_part_66"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">58.7%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">嵌入式的开发环境</i><i class="black">既能</i><i class="black">在W</i><i class="blue">in</i><i class="black">dows</i><i class="blue">下搭建</i>，<i class="black">又能</i><i class="black">在Mac</i><i class="black"> OS或</i><i class="blue">Linux下搭建</i>，<i class="black">由于本设计使用</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">的结构和工作原理。第五章<font color="red">，嵌入式Linux开发环境的搭建</font>。研究<font color="red">Linux</font>内核的结构特点，重点研究<font color="red">Linux </font>内核<font color="red">在嵌入式环境下</font></p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《基于arm9的嵌入式图像采集系统的设计 》</li><li>作者：徐巍</li><li>专业：物理电子学</li><li>年份：2009</li><li>机构：南京理工大学</li></ul></div><div id="report_part_67"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">95.56%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">般都是gcc</i>、<i class="blue">ld等</i>，<i class="blue">它们编译出来的程序一般都是运行在x86平台上的</i>，<i class="black">对</i><i class="blue">于ARM平台上的嵌入式</i><i class="black">设</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">编译</font>工具链为<font color="red">gcc、ld、</font>objcopy、objdump等, <font color="red">它们编译出来的程序在x86平台上运行</font>...由<font color="red">于ARM一般都是</font>用<font color="red">于嵌入式</font>系 统,而<font color="red">嵌入式</font>系统的特性决定了<font color="red">在ARM平台上编</font>写<font color="red">程序</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《基于ARM的GPS定位系统的研究与实现_百度文库》</li><li>入库时间：2014-02-28</li></ul></div><div id="report_part_68"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">57.45%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">本是</i><i class="black">用来编译</i><i class="blue">嵌入式Linux</i><i class="black">内核或</i><i class="blue">Linux应用的</i>，<i class="black">EABI版本适</i><i class="black">用于编译</i><i class="black">自己</i><i class="blue">的嵌入式操作系统</i><i class="black">或</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">嵌入式操作系统Linux的应用</font>移植·57· <font color="red">嵌入式操作系统Linux的应用</font>移植王勇，杨勇(南京邮电大学自动化学院，江苏南京</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《嵌入式操作系统Linux的应用移植》</li><li>作者：王勇 杨勇</li><li>出处：《测控技术》 2006，25(10)：57 -60</li><li>机构：南京邮电大学自动化学院,江苏南京210003</li></ul></div><div id="report_part_69"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">54.76%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">把交叉工具链</i><i class="black">的目录</i><i class="blue">添加到</i><i class="black">系统</i><i class="blue">环境变量中</i>，<i class="black">具体为</i><i class="blue">编辑</i><i class="black">用户目录下</i><i class="black">的</i>.<i class="blue">bashrc文件</i>，<i class="blue">命令</i><i class="black">为：</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">自动设置<font color="red">环境变量</font>PATH，可以<font color="red">编辑</font>．<font color="red">bashrc文件，把</font>上面<font color="red">的命令添加到</font>．<font color="red">bashrc文件中</font>。至此，Bl<font color="red">ac</font>kfin</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《μ Clinux在Blackfin561处理器上的应用》</li><li>作者：魏坤 武富春</li><li>出处：《电脑开发与应用》 2008，21(5)：33 -35</li><li>机构：北方自动控制技术研究所,太原030006</li></ul></div><div id="report_part_70"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">60%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">最</i><i class="black">后是输出</i><i class="blue">环境变量</i>，<i class="black">保存</i><i class="blue">修改</i><i class="black">的</i>.<i class="blue">bashrc文件</i><i class="black">即可：</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">通过编辑．<font color="red">bashrc文件修改环境变量</font>#vim ．<font color="red">bashrc</font> <font color="red">修改后</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《RHEL5下利用MPICH2配置并行运算集群》</li><li>作者：李剑 罗元成</li><li>出处：《光盘技术》 2009，(5)：33 -35</li><li>机构：重庆工程职业技术学院计算机系,重庆400037</li></ul></div><div id="report_part_71"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">71.11%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">任务的</i><i class="black">优先级号</i>，<i class="black">即</i><i class="blue">任务</i><i class="black">号</i>，<i class="blue">tcb</i><i class="black">_n</i><i class="blue">ext</i><i class="black">和</i><i class="blue">tcb</i><i class="black">_p</i><i class="blue">rev</i><i class="black">分别</i><i class="blue">指向下一个</i><i class="black">和</i><i class="blue">前一个任务控制块</i>，<i class="black">t</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"> <font color="red">tcb</font>*TCBN<font color="red">ext</font>；<font color="red">指向下一个任务控制块的指</font>针／s<font color="red">tr</font>u<font color="red">ct</font> <font color="red">tcb</font>*TCBP<font color="red">rev</font>；<font color="red">指向前一个任务控制块的指</font>针／EVENT</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《一种嵌入式多机系统的设计和实现》</li><li>作者：万静 何云斌 王培东</li><li>出处：《齐齐哈尔大学学报：自然科学版》 2004，20(2)：62 -65</li><li>机构：哈尔滨理工大学计控学院，哈尔滨150080</li></ul></div><div id="report_part_72"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">66.67%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">当定义好</i><i class="blue">任务控制块的所有</i><i class="black">变量后</i>，<i class="black">需要把</i><i class="blue">空任务块</i><i class="black">连</i><i class="blue">接成空任务块控制链表</i>，<i class="black">主要代码</i><i class="blue">如下图所示</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">，如下图所示，所有任务控制块</font>OSjCBs被<font color="red">链接成空任务控制块的</font>单向<font color="red">链表</font>。<font color="red">当任务</font>一旦建立<font color="red">，空任务控制块</font>指针</p></div><ul class="sidebars song"><li>来源：维普论文库</li><li>篇名：《嵌入式操作系统的设计与实现 》</li><li>作者：马少丹</li><li>专业：通信与信息系统</li><li>年份：2002</li><li>机构：南开大学</li></ul></div><div id="report_part_73"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">71.93%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">该函数</i><i class="black">首</i><i class="blue">先判断</i><i class="black">当前</i><i class="blue">运行的任务</i><i class="black">与</i><i class="blue">最高优先级的就绪任务是否</i><i class="black">相同</i>，<i class="black">如果</i><i class="black">不相同</i>，<i class="black">则</i><i class="blue">进行任务的</i><i class="black">调度</i>，<i class="black">选择</i><i class="blue">最高优先级就绪的任务</i><i class="black">来</i><i class="blue">运行</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">它总<font color="red">是运行优先级最高的就绪任务</font>,不支持时间片轮转...执行完后内核要<font color="red">判断</font>此时<font color="red">是否</font>有更<font color="red">高优先级</font>,新<font color="red">的任务</font>...()<font color="red">函数</font>,<font color="red">该任务进</font>入等待状态,一直到延时时间到,这2...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《嵌入式操作系统任务切换方法对比分析_存储_方案_中国智能化网》</li><li>入库时间：2011-07-29</li></ul></div><div id="report_part_74"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">68.18%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">如果</i><i class="black">需</i><i class="blue">要挂起任务自身</i>，<i class="black">传递</i><i class="blue">的参数为OS_PRIO_SELF</i>，<i class="black">其它</i><i class="blue">任务</i><i class="black">只需传递相应</i><i class="blue">的任务</i><i class="black">号即可</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">如果任务要挂起自身</font>,则<font color="red">参数</font>必须<font color="red">为OS_PRIO_SELF</font> //恢复<font color="red">任务</font> INT8U <font color="red">OS</font>TaskResume... 若调用函<font color="red">数OS</font>TaskQuery()查询成功,则函数将返回<font color="red">OS_</font>N<font color="red">O_ERR</font>,并把查询得到<font color="red">的任务</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《uCOS study note_song_新浪博客》</li><li>入库时间：2012-03-31</li></ul></div><div id="report_part_75"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">80.43%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">任务的恢复</i><i class="black">只能通过其它</i><i class="blue">任务</i><i class="black">来</i><i class="blue">恢复被挂起的任务</i>，<i class="blue">函数</i><i class="black">为r</i><i class="blue">esume</i><i class="black">_t</i><i class="blue">ask()</i>。<i class="blue">该函数将任务状态</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">。· <font color="red">恢复任务</font>R<font color="red">esume</font>T<font color="red">ask()。</font>是<font color="red">恢复挂起任务的</font>唯一途径。当<font color="red">任务</font>等待条件满足时<font color="red">，该函数将被</font>调用，使<font color="red">挂起任务恢复</font>到就绪<font color="red">状态</font></p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《小卫星星载操作系统内核的设计》</li><li>作者：王永恒 廖明宏</li><li>出处：《计算机工程》 2002，28(11)：111 -113</li><li>机构：哈尔滨工业大学计算机学院，哈尔滨150001</li></ul></div><div id="report_part_76"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">71.11%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">执行中断处理前</i>，<i class="black">首先需</i><i class="blue">要保存</i><i class="black">任务</i><i class="blue">现场</i>，<i class="black">然</i><i class="blue">后跳转到中断处理程序处理中断</i>，<i class="blue">处理完</i><i class="black">毕</i><i class="black">后</i>，<i class="black">退出</i><i class="blue">中断</i>，<i class="black">恢复任务</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">3、当异常<font color="red">中断</font>发生时,系统<font color="red">执行完</font>当前指令后,将<font color="red">跳转到</font>相应的异常<font color="red">中断处理程序处执行</font>。在进入异常<font color="red">中断处理程序</font>时,<font color="red">要保存</font>被<font color="red">中断</font>的<font color="red">程序</font>的<font color="red">执行现场</font>,在从异常<font color="red">中断处理</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《ARM处理器异常中断处理_mscyhll_百度空间》</li><li>入库时间：2010-07-19</li></ul></div><div id="report_part_77"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">62.5%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">有更</i><i class="blue">高优先级就绪的任务</i>，<i class="blue">那么</i><i class="black">会恢复被</i><i class="blue">中断的任务</i><i class="black">接着</i><i class="blue">运行</i>，<i class="black">否则会去</i><i class="blue">运行</i><i class="black">更</i><i class="blue">高优先级就绪的任务</i>，<i class="black">代码</i><i class="black">如下所示</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">最<font color="red">高优先级任务</font>一 旦<font color="red">就绪</font>,总能得到CPU控制权。如果在一个<font color="red">中断</font>处 理过程中某<font color="red">优先级高的任务就绪</font>,<font color="red">那么</font>在<font color="red">中断</font>程序完 成时,<font color="red">优先级高的任务</font>得以<font color="red">运行</font>;支持多<font color="red">任务</font>: ...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《UC_OS-Ⅱ中优先级抢占的时间片调度算法的实现_百度文库》</li><li>入库时间：2011-10-18</li></ul></div><div id="report_part_78"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">64.44%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">如果</i><i class="black">没</i><i class="blue">有更高优先级就绪任务</i>，<i class="black">那么</i><i class="blue">函数就会</i><i class="black">返回</i><i class="black">到irq_isr</i><i class="blue">函数</i><i class="black">处</i>，<i class="black">接着</i><i class="blue">恢复</i><i class="black">被</i><i class="blue">中断的任务</i><i class="black">去运</i><i class="black">行</i>，</p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">服<font color="red">务函数</font>执行完毕后,<font color="red">如果有更高优先级的任务就绪</font>,则RTOS<font color="red">就会</font>调用<font color="red">任务</font>调度<font color="red">函数</font>。...<font color="red">级高</font>,则在所<font color="red">有中断</font>退出后或调用OSSched()后,<font color="red">高优先级的任务</font>将得到消息而<font color="red">恢复</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《Small RTOS函数参考手册 - X.Fountain的日志 - 网易博客》</li><li>入库时间：2011-03-20</li></ul></div><div id="report_part_79"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">89.36%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">内存控制块</i><i class="black">中</i><i class="blue">mem</i><i class="black">_a</i><i class="blue">ddr指向内存分区的起始地址</i>，<i class="blue">mem</i><i class="black">_f</i><i class="blue">ree</i><i class="black">_l</i><i class="blue">ist指向下一个内存块地</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">2014年3月14日&nbsp;-&nbsp; .OSM<font color="red">em</font>A<font color="red">ddr</font>是<font color="red">指向内存分区起始地址的指</font>针。它在建立<font color="red">内存分区</font>[见7.1节,... .OSM<font color="red">em</font>F<font color="red">ree</font>L<font color="red">ist</font>是<font color="red">指向下一个</font>空闲<font color="red">内存控制块</font>或者<font color="red">下一个</font>空闲<font color="red">的内存块的</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《μC/OS-II的内存管理 - 嵌入式软件 - 21ic中国电子网》</li><li>入库时间：2014-03-14</li></ul></div><div id="report_part_80"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">68.42%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="black">下面针对</i><i class="blue">操作系统的各个功能模块进行</i><i class="black">测试</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei">，实际<font color="red">进行操作系统各个功能模块的</font>设计与实验，理论</p></div><ul class="sidebars song"><li>来源：中文期刊数据库</li><li>篇名：《改革《操作系统》课程设置强化学生的基础知识》</li><li>作者：蒲晓蓉 陆庆 耿技</li><li>出处：《电子科技大学学报：社会科学版》 2002，4(2)：99 -100</li><li>机构：电子科技大学，成都610054</li></ul></div><div id="report_part_81"><div class="sidebars song" style="line-height:2.4em"><b class="block yahei f16" style="padding:10px 0">该片段相似度：<b class="tahoma f16">59.46%</b></b></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_blue.gif"/> 送检论文片段：</b><p class="f14 yahei"><i class="blue">任务的管理</i><i class="black">功能</i><i class="blue">除了任务的创建</i><i class="black">和调度</i><i class="blue">切换</i><i class="black">外</i>，<i class="black">还能</i><i class="blue">进行挂起任务</i>、<i class="blue">恢复任务</i>、<i class="blue">删除任务的操作</i>。<i class="black">时</i><i class="blue">间的管理</i><i class="black">功能包括</i><i class="blue">任务的</i><i class="black">延时</i>、<i class="black">取消延时</i>、<i class="black">获取系统</i><i class="blue">运行</i><i class="black">时</i><i class="black">间和设置系统</i><i class="blue">运行</i><i class="black">时</i><i class="black">间</i></p></div><div class="sidebars song" style="line-height:2.4em"><b class="block f14 yahei"><img src="images/icon_arrow_red.gif"/> 相似论文片段：</b><p class="f14 yahei"><font color="red">任务的创建、</font>启动<font color="red">、运行、切换</font>以及<font color="red">任务</font>之<font color="red">间的</font>通信都<font color="red">进行了</font>研究,论文详细说明<font color="red">了任务管理的</font>具体<font color="red">操作</font>指令,这些指令是:<font color="red">任务创建、任务</font>启动<font color="red">、任务挂起、任务恢复、任务删除</font>...</p></div><ul class="sidebars song"><li>来源：互联网数据</li><li>篇名：《星上嵌入式实时ACOS任务管理研究--《中国人民解放军国防科学技术...》</li><li>入库时间：2013-09-12</li></ul></div></div><div class="corp tahoma noprint">
	维普论文检测系统 |  客服热线：400-638-5550 | 客服QQ：4006385550 | 客服邮箱：vpcs@cqvip.com<br/>
	【维普资讯 荣誉出品】版权所有© 2014-2015
</div>
</body>
</html>
